{
    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {
        "location": {
			"defaultValue": "[resourceGroup().location]",
            "type": "String"
        },
        "alteonsAzureFuncName": { 
			"defaultValue": "func",
            "type": "String"
        },
        "alteonAzureFuncServerfarmsPlanName": { 
			"defaultValue": "serverfarmname",
            "type": "String"
        },
        "alteonsAzureFuncServerFarmId": { 
			"defaultValue": "serverfarm",
            "type": "String"
        },        
        "storageAccountName": { 
			"defaultValue": "storageaccountname",
            "type": "String"
        },
        "storageAccountType": { 
			"defaultValue": "storageaccounttype",
            "type": "String"
        },        
        "blobContainerName": { 
			"defaultValue": "blobcontainername",
            "type": "String"
        },
        "alteonAzureFuncHostNameBindingsName": {
        "defaultValue": "hostbindingname",
           "type": "String"
        },  
        "alteonAzureFuncParams": {
            "type": "object",
            "metadata": {
                "description": "" 
            }
        }                                                                                              
    }, 
    "variables": 
    {
        "azureFunctionJsonParams":  "[concat('{\n', '\t\"Azure\":\n', '\t{\n', '\t\t\"LoadBalancerName\": \"', parameters('alteonAzureFuncParams').Azure.LoadBalancerName, '\",\n', '\t\t\"SubscriptionId\": \"', parameters('alteonAzureFuncParams').Azure.SubscriptionId,'\",\n', '\t\t\"TenantId\": \"', parameters('alteonAzureFuncParams').Azure.TenantID, '\",\n', '\t\t\"ClientId\": \"', parameters('alteonAzureFuncParams').Azure.ClientID, '\",\n', '\t\t\"ClientSecret\": \"' , parameters('alteonAzureFuncParams').Azure.ClientSecret, '\",\n', '\t\t\"ResourceGroupName\": \"', parameters('alteonAzureFuncParams').Azure.resourceGroupName, '\",\n', '\t\t\"StorageAccount\": \"', parameters('alteonAzureFuncParams').Azure.StorageAccount, '\",\n', '\t\t\"ContainerName\": \"', parameters('alteonAzureFuncParams').Azure.ContainerName, '\"\n', '\t\t\n', '\t},\n', '\t\"GelLicense\":\n', '\t{\n', '\t\t\"EntitlementId\": \"', parameters('alteonAzureFuncParams').Gel.EntitlementId, '\",\n', '\t\t\"Throughput\": \"', parameters('alteonAzureFuncParams').Gel.ThroughputLicense, '\",\n', '\t\t\"Subscriber\": \"', parameters('alteonAzureFuncParams').Gel.AddOnSubsciption, '\"\n', '\t},\n', '\t\"Certificate\":\n', '\t{\n', '\t\t\"Id\": \"', parameters('alteonAzureFuncParams').Ssl.sslCertificateName, '\",\n', '\t\t\"Policy\": \"', parameters('alteonAzureFuncParams').Ssl.sslPolicyName, '\",\n', '\t\t\"Passphrase\": \"', parameters('alteonAzureFuncParams').Ssl.SslPrivateKeyPassphrase, '\",\n', '\t\t\"HttpsRport\": \"', parameters('alteonAzureFuncParams').Ssl.SlbHttpsRport, '\",\n', '\t\t\"SlbHttpService\": \"', parameters('alteonAzureFuncParams').Ssl.SlbHttpService, '\",\n', '\t\t\"SlbHttpsService\": \"', parameters('alteonAzureFuncParams').Ssl.SlbHttpsService, '\",\n', '\t\t\"Data\": \"', parameters('alteonAzureFuncParams').Ssl.sslCertNkeyFile, '\"\n', '   \n', '\t}   \n', '}\n')]"    
    },
    "resources": [    
    {
        "type": "Microsoft.Storage/storageAccounts",
        "name": "[parameters('storageAccountName')]",
        "apiVersion": "2018-07-01",
        "location": "[parameters('location')]",
        "kind": "BlobStorage",
        "sku": {
            "name": "[parameters('storageAccountType')]",
            "tier": "Standard"
        },
        "properties": 
        {
            "accessTier": "Hot"
        },
        "resources": [
            {
                "name": "[concat('default/', parameters('blobContainerName'))]",
                "type": "blobServices/containers",
                "apiVersion": "2018-03-01-preview",
                "dependsOn": [
                    "[parameters('storageAccountName')]"
                ],
                "properties": {
                "publicAccess": "None"
                }                   
            }  
        ]            
    },         
    {
        "type": "Microsoft.Web/serverfarms",
        "sku": {
            "name": "Y1",
            "tier": "Dynamic",
            "size": "Y1",
            "family": "Y",
            "capacity": 0
        },
        "kind": "functionapp",
        "name": "[parameters('alteonAzureFuncServerfarmsPlanName')]",
        "apiVersion": "2017-08-01",
        "location": "[parameters('location')]",
        "scale": null,
        "properties": {
            "name": "[parameters('alteonAzureFuncServerfarmsPlanName')]",
            "workerTierName": null,
            "adminSiteName": null,
            "hostingEnvironmentProfile": null,
            "perSiteScaling": false,
            "reserved": false,
            "targetWorkerCount": 0,
            "targetWorkerSizeId": 0
        },
        "dependsOn": []
    },      
    {
        "type": "Microsoft.Web/sites",
        "kind": "functionapp",
        "name": "[parameters('alteonsAzureFuncName')]",
        "apiVersion": "2016-08-01",
        "location": "[parameters('location')]",
        "scale": null,
        "properties": {

            "serverFarmId": "[parameters('alteonsAzureFuncServerFarmId')]",
            "reserved": false,
            "siteConfig": null,
            "scmSiteAlsoStopped": false,
            "hostingEnvironmentProfile": null,
            "clientAffinityEnabled": false,
            "clientCertEnabled": false,
            "hostNamesDisabled": false,
            "containerSize": 1536,
            "dailyMemoryTimeQuota": 0,
            "cloningInfo": null
        },
        "dependsOn": [
            "[resourceId('Microsoft.Web/serverfarms', parameters('alteonAzureFuncServerfarmsPlanName'))]"
        ],
        "resources": [           
            {
                "apiVersion": "2018-02-01",
                "name": "appsettings",
                "type": "config",
                "dependsOn": [
                    "[resourceId('Microsoft.Web/sites', parameters('alteonsAzureFuncName'))]",
                    "[parameters('storageAccountName')]"
                ],
                "properties": {
                    "AzureWebJobsStorage": "[concat('DefaultEndpointsProtocol=https;AccountName=',parameters('storageAccountName'),';AccountKey=',listkeys(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), '2018-02-01').keys[0].value)]", 
                    "AzureWebJobsDashboardWEBSITE_CONTENTAZUREFILECONNECTIONSTRING": "[concat('DefaultEndpointsProtocol=https;AccountName=',parameters('storageAccountName'),';AccountKey=',listkeys(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), '2018-02-01').keys[0].value)]", 
                    "FUNCTIONS_EXTENSION_VERSION": "~2",
                    "AzureWebJobsSecretStorageType": "Files"
                }
            },
            {
            "apiVersion": "2018-02-01",
            "name": "TestFunctionCM",
            "type": "functions",
            "dependsOn": [
                "[resourceId('Microsoft.Web/sites', parameters('alteonsAzureFuncName'))]"
            ],
            "properties": {
                "config": {
                    "bindings": [
                        {
                          "authLevel": "anonymous",
                          "name": "req",
                          "type": "httpTrigger",
                          "direction": "in"
                        },
                        {
                          "name": "res",
                          "type": "http",
                          "direction": "out"
                        }
                      ]    
              },
              "files": {
                "run.csx": "[concat('#r \"Newtonsoft.Json\"\n', '#r \"System.Web\"\n', '#r \"System.Threading\"\n', '#r \"Microsoft.WindowsAzure.Storage\"\n', ' \n', '\n', 'using System.IO;\n', 'using Microsoft.AspNetCore.Mvc;\n', 'using Microsoft.Azure.WebJobs;\n', 'using Microsoft.AspNetCore.Http;\n', 'using Microsoft.Azure.WebJobs.Host;\n', 'using Newtonsoft.Json;\n', 'using Microsoft.Extensions.Logging;\n', '\n', 'using Microsoft.Extensions.Primitives;\n', '\n', 'using System.Threading.Tasks;\n', 'using System;\n', 'using System.Net;\n', 'using System.Net.Http;\n', 'using System.Net.Http.Headers;\n', 'using System.Web;\n', 'using System.Text;\n', 'using System.Threading;\n', '\n', 'using System.Collections.Generic;\n', 'using System.Security.Cryptography;\n', '\n', '/*\n', 'TODO 1: delete old commented code\n', 'TODO 2: it should be possible to unite several functions/remove code duplications (i.e. AlteonPostRequest/AlteonGetRequest)\n', 'TODO 3: consider separating the AlteonApplyConfig from AlteonPutConfig (and retries separately on put and apply)\n', 'TODO 4: errors handling (timeouts, non OK responses, etc.)\n', 'TODO 5: through all this code, i don''t verify existence of correct post data. in case some are missing, behavior is unexpected\n', '{\n', '    \"firstApply\": \"false\",\n', '    \"username\": \"admin\",\n', '    \"password\": \"admin\",\n', '    \"passphrase\": \"radware\",\n', '    \"instanceName\": \"demoAlteonCluster999Vmss_1\",\n', '    \"accessIp\": \"168.61.40.73\", // used for testing\n', '    \"accessPort\": \"8443\",       // used for testing\n', '}\n', '*/\n', '\n', 'class Globals\n', '{\n', '    // some public global variables\n', '    public static string   _remoteIp = \"\";\n', '    public static string   _passphrase = \"\";\n', '    public static string   _lbName = \"\";\n', '    public static string   _instanceId = \"\";\n', '    public static dynamic  _requestData = null;\n', '    public static dynamic  _deployParams = null;\n', '    public static ILogger  _log = null;\n', '    public static AuthenticationHeaderValue _authHeader = null;\n', '\n', '    public static async Task<bool> Init(HttpRequest req, ILogger log, Microsoft.Azure.WebJobs.ExecutionContext context)\n', '    {\n', '        Globals._log = log;\n', '        string requestBody = \"\";\n', '        try\n', '        {\n', '            requestBody = await new StreamReader(req.Body).ReadToEndAsync();\n', '            _requestData = JsonConvert.DeserializeObject(requestBody);\n', '            log.LogInformation($\"Globals.Set - extracting global data from: {_requestData}\");\n', '\n', '            _authHeader = Utils.GenerateAuthorizationValue();\n', '            _passphrase = ExtractCallerPassphrase();\n', '            (string name, string id) result =  ExtractInstanceId(); // extract scaleset name and Alteon''s instance ID\n', '            _instanceId = result.id;\n', '\n', '            // this is for testing only (i.e. when using postman)\n', '            _remoteIp = _requestData?.accessIp; // does not exist when sent from Alteon\n', '            if (string.IsNullOrEmpty(_remoteIp))\n', '            {\n', '                _remoteIp = req.HttpContext.Connection.RemoteIpAddress.ToString();\n', '            }\n', '            log.LogInformation($\"Globals.Set - remote ip: {_remoteIp}\");\n', '\n', '            // some parameters are given in the deployment process and passed to this function by JSON file\n', '            string deployParams = System.IO.File.ReadAllText($@\"{context.FunctionDirectory}\\function_params.json\");\n', '            _deployParams = JsonConvert.DeserializeObject(deployParams);\n', '\n', '            _lbName = _deployParams?.Azure?.LoadBalancerName;\n', '\n', '            AzureInterface.Init();\n', '            AzureStorage.Init(_deployParams?.Azure?.StorageAccount.ToString(), _deployParams?.Azure?.ContainerName.ToString(), \"clusterConfig.tgz\");\n', '        }\n', '        catch (Exception ex)\n', '        {\n', '            log.LogError($\"Globals.Init - an exception occured. request body: {requestBody}\\nException: {ex.ToString()}\");\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    static string ExtractCallerPassphrase()\n', '    {\n', '        // extract the passphrase from the request data\n', '        string passphrase = _requestData?.passphrase;\n', '        if (string.IsNullOrEmpty(passphrase))\n', '        {\n', '            return \"radware\";\n', '        }\n', '        \n', '        return passphrase;\n', '    }\n', '\n', '    public static (string name, string id) ExtractInstanceId()\n', '    {\n', '        // extract instance ID from the instance Name (<instance>_<id>)\n', '        string instanceName = _requestData?.instanceName;\n', '        if (string.IsNullOrEmpty(instanceName))\n', '        {\n', '            _log.LogError(\"request does not contain instance name\");\n', '            return (\"\", \"\");\n', '        }\n', '\n', '        string[] parts = instanceName.Split(''_'');\n', '        if (parts.Length < 2)\n', '        {\n', '            _log.LogError(\"request contain instance name but not instance ID\");\n', '            return (\"\", \"\");\n', '        }\n', '\n', '        return (parts[0], parts[1]);\n', '    }\n', '};\n', '\n', 'class FuncResult\n', '{\n', '    public FuncResult(bool status = false, string message = \"\", object other = null)\n', '    {\n', '        this.status = status;\n', '        this.message = message;\n', '        this.other = other;\n', '    }\n', '\n', '    public bool status {get; set;}\n', '    public string message {get; set;}\n', '    public object other {get; set;}\n', '};\n', '\n', '// handle configuration tasks (read/write to storage)\n', 'class Configuration\n', '{\n', '    public static async Task<bool> Exists()\n', '    {\n', '        return await AzureStorage.Exists();\n', '    }\n', '\n', '    // save configuration to the storage (used after get-config request)\n', '    public static async Task<bool> Save(byte[] responseContent)\n', '    {\n', '        await AzureStorage.RestUploadBlob(responseContent);\n', '        Globals._log.LogInformation($\"Configuration.Save - saved {responseContent.Count()} bytes to configuration blob\");\n', '\n', '        return true;\n', '    }\n', '\n', '    // read configuration from storage and return it as file content\n', '    public static async Task<ByteArrayContent> GetContent()\n', '    {\n', '        Globals._log.LogInformation($\"Configuration.GetContent - entry\");\n', '\n', '        // try to get configuration file from storage\n', '        byte[] blobContent = await AzureStorage.RestDownloadBlob();\n', '        if (null == blobContent || blobContent.Length == 0)\n', '        {\n', '            Globals._log.LogError($\"Configuration.GetContent - failed to read configuration blob from storage\");\n', '\n', '            return null;\n', '        }\n', '\n', '        Globals._log.LogInformation($\"Configuration.GetContent - total of {blobContent.Length} bytes read from storage\");\n', '\n', '        return new ByteArrayContent(blobContent);\n', '    }\n', '};\n', '\n', '// handle reading and writing storage''s blob content\n', '// currently, this class supports handling a single blob only\n', '/* \n', 'in order to read/write storage blobs using REST API I''m following the example in this link: \n', 'https://stackoverflow.com/questions/48202964/azure-blob-storage-rest-call-from-c-sharp\n', 'in general, the idea in this implementation is to acquire an access key from the storage and use \n', 'it as a key to encypt and generate an acces token (see ''AuthorizationHeader'' below). the access \n', 'token is a hash performed on a string that is a sort of permission request (string to sign). \n', 'for more details you can check the following links:\n', 'https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas\n', 'https://docs.microsoft.com/en-us/rest/api/storageservices/service-sas-examples \n', 'and a lot more when searching for \"REST API storage blob\"\n', '*/ \n', 'class AzureStorage\n', '{\n', '    static string  _accountName = \"\";\n', '    static string  _containerName = \"\";\n', '    static string  _blobName = \"\";\n', '    static string  _blobType = \"BlockBlob\";\n', '    static dynamic _accessKeys = null;\n', '    static byte[]  _blobContent;\n', '    static string  _version = \"2017-04-17\";\n', '\n', '    public static void Init(string accountName, string containerName, string blobName)\n', '    {\n', '        _accountName = accountName;\n', '        _containerName = containerName;\n', '        _blobName = blobName;\n', '        _accessKeys = null; // i want to retrieve the access keys once per apply/first-apply\n', '        _blobContent = new byte[0]; // enable content reuse (i need to copy the content after each put-config)\n', '    }\n', '\n', '    // build the REST API to get a list of storage access keys for a specific account\n', '    static string GenerateListKeysUrl()\n', '    {\n', '        string subscriptionId = Globals._deployParams?.Azure.SubscriptionId;\n', '        string resourceGroup = Globals._deployParams?.Azure.ResourceGroupName;\n', '        string apiVersion = \"2018-07-01\";\n', '\n', '        return $\"https://management.azure.com/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Storage/storageAccounts/{_accountName}/listKeys?api-version={apiVersion}\";\n', '    }\n', '\n', '    // retrieve the storage access keys (2 keys)\n', '    static async Task<bool> GetAccessKeys()\n', '    {\n', '        Globals._log.LogInformation(\"AzureStorage.GetAccessKeys - entry\");\n', '        if (null != _accessKeys)\n', '        {\n', '            Globals._log.LogInformation(\"AzureStorage.GetAccessKeys - keys already retrieved, return them\");\n', '            return true;\n', '        }\n', '\n', '        // generate the appropriate URL\n', '        string queryUrl = GenerateListKeysUrl();\n', '\n', '        // send GET request to ARM to retrieve NAT rules\n', '        HttpResponseMessage response = await AzureInterface.PostHttpResponse(queryUrl);\n', '        if (null == response || response.StatusCode != HttpStatusCode.OK)\n', '        {\n', '            Globals._log.LogError($\"AzureStorage.GetAccessKeys - failed to retrieve access keys. Status: [{response?.StatusCode}]\");\n', '            return false;\n', '        }\n', '\n', '        string responseContent = await response.Content.ReadAsStringAsync();\n', '\n', '        Globals._log.LogInformation($\"AzureStorage.GetAccessKeys - response: {responseContent}\");\n', '\n', '        _accessKeys = JsonConvert.DeserializeObject(responseContent);\n', '\n', '        return true;\n', '    }\n', '\n', '    static HttpWebRequest CreateBlobRequest(string method, string time, int contentLength = 0)\n', '    {\n', '        string requestUri = $\"https://{_accountName}.blob.core.windows.net/{_containerName}/{_blobName}\";\n', '\n', '        HttpWebRequest request = (HttpWebRequest)WebRequest.Create(requestUri);\n', '\n', '        request.Method = method;\n', '        if (contentLength > 0)\n', '        {\n', '            request.ContentType = \"text/plain; charset=UTF-8\";\n', '            request.ContentLength = contentLength;\n', '        }\n', '\n', '        request.Headers.Add(\"x-ms-version\", _version);\n', '        request.Headers.Add(\"x-ms-date\", time);\n', '        request.Headers.Add(\"x-ms-blob-type\", _blobType);\n', '\n', '        return request;\n', '    }\n', '\n', '    // generate the authorization token and header\n', '    static string AuthorizationHeader(string method, string now, HttpWebRequest request, string accessKey)\n', '    {\n', '        string headerResource = $\"x-ms-blob-type:{_blobType}\\nx-ms-date:{now}\\nx-ms-version:{_version}\";\n', '        string urlResource = $\"/{_accountName}/{_containerName}/{_blobName}\";\n', '        string contentLength = (method == \"GET\" || method == \"HEAD\") ? String.Empty : request.ContentLength.ToString();\n', '        string stringToSign = $\"{method}\\n\\n\\n{contentLength}\\n\\n{request.ContentType}\\n\\n\\n\\n\\n\\n\\n{headerResource}\\n{urlResource}\";\n', '\n', '        Globals._log.LogInformation($\"AzureStorage.AuthorizationHeader - string to sign: {stringToSign}\");\n', '\n', '        HMACSHA256 hmac = new HMACSHA256(Convert.FromBase64String(accessKey));\n', '        string signature = Convert.ToBase64String(hmac.ComputeHash(Encoding.UTF8.GetBytes(stringToSign)));\n', '\n', '        Globals._log.LogInformation($\"AzureStorage.AuthorizationHeader - signature: {signature}\");\n', '\n', '        return $\"SharedKey {_accountName}:{signature}\";\n', '    }\n', '\n', '    // upload a blob/file to the storage using REST API\n', '    public static async Task<bool> RestUploadBlob(byte[] content)\n', '    {\n', '        Globals._log.LogInformation(\"AzureStorage.RestUploadBlob - entry\");\n', '\n', '        // save content to local _blobContent to be reused\n', '        _blobContent = content;\n', '\n', '        // first get the access key\n', '        if (!await GetAccessKeys())\n', '        {\n', '            Globals._log.LogError(\"AzureStorage.RestUploadBlob - failed to retrieve access keys\");\n', '\n', '            return false;\n', '        }\n', '\n', '        try\n', '        {\n', '            string method = \"PUT\";\n', '            string now = DateTime.UtcNow.ToString(\"R\");\n', '\n', '            int contentLength = content.Length;\n', '            Globals._log.LogInformation($\"AzureStorage.RestUploadBlob - total of {contentLength} bytes will be written to storage blob\");\n', '\n', '            HttpWebRequest request = CreateBlobRequest(method, now, contentLength);\n', '\n', '            string token = AuthorizationHeader(method, now, request, _accessKeys.keys[0].value.ToString());\n', '            Globals._log.LogInformation($\"AzureStorage.RestUploadBlob - time: {now}, auth header: {token}\");\n', '\n', '            request.Headers.Add(\"Authorization\", token);\n', '\n', '            using (Stream requestStream = request.GetRequestStream())\n', '            {\n', '                requestStream.Write(content, 0, contentLength);\n', '            }\n', '\n', '            using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())\n', '            {\n', '                Globals._log.LogInformation($\"AzureStorage.RestUploadBlob - done with status: {response.StatusCode.ToString()}\");\n', '            }\n', '\n', '            return true;\n', '        }\n', '        catch (Exception ex)\n', '        {\n', '            Globals._log.LogError($\"AzureStorage.RestUploadBlob - an exception occured. Blob: {_blobName}\\nException: {ex.ToString()}\");\n', '            return false;\n', '        }\n', '    }\n', '\n', '    public static async Task<byte[]> RestDownloadBlob()\n', '    {\n', '        // if content already downloaded, return it\n', '        if (_blobContent.Length > 0)\n', '        {\n', '            Globals._log.LogInformation($\"AzureStorage.RestDownloadBlob - blob already retrieved, return it\");\n', '            return _blobContent;\n', '        }\n', '\n', '        Globals._log.LogInformation($\"AzureStorage.RestDownloadBlob - first time retrieving blob\");\n', '\n', '        // first get the access key\n', '        if (!await GetAccessKeys())\n', '        {\n', '            Globals._log.LogError(\"AzureStorage.RestDownloadBlob - failed to retrieve access keys\");\n', '\n', '            return null;\n', '        }\n', '\n', '        try\n', '        {\n', '            Globals._log.LogInformation($\"AzureStorage.RestDownloadBlob - got {_accessKeys.keys.Count} access keys\");\n', '\n', '            string method = \"GET\";\n', '            string now = DateTime.UtcNow.ToString(\"R\");\n', '\n', '            Globals._log.LogInformation(\"AzureStorage.RestDownloadBlob - creating the request\");\n', '            HttpWebRequest request = CreateBlobRequest(method, now);\n', '\n', '            string token = AuthorizationHeader(method, now, request, _accessKeys.keys[0].value.ToString());\n', '            Globals._log.LogInformation($\"AzureStorage.RestDownloadBlob - time: {now}, token: {token}\");\n', '\n', '            request.Headers.Add(\"Authorization\", token);\n', '\n', '            using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())\n', '            {\n', '                Globals._log.LogInformation($\"AzureStorage.RestDownloadBlob - done with status: {response.StatusCode.ToString()}. Content length : {response.ContentLength}\");\n', '                using (var reader = new System.IO.BinaryReader(response.GetResponseStream()))\n', '                {\n', '                    _blobContent = reader.ReadBytes((int)response.ContentLength);\n', '                    Globals._log.LogInformation($\"AzureStorage.RestDownloadBlob - blob length: {_blobContent.Length}\");\n', '\n', '                    return _blobContent;\n', '                }\n', '            }\n', '        }\n', '        catch (Exception ex)\n', '        {\n', '            Globals._log.LogError($\"AzureStorage.RestDownloadBlob - an exception occured. Blob: {_blobName}\\nException: {ex.ToString()}\");\n', '            return null;\n', '        }\n', '    }\n', '\n', '    // check existence of the configuration blob\n', '    public static async Task<bool> Exists()\n', '    {\n', '        // this will either return immediately (blob already retrieved) or retrieve the\n', '        // blob for the first time. the later will be usefull on next calls to RestDownloadBlob\n', '        byte[] blobContent = await AzureStorage.RestDownloadBlob();\n', '\n', '        if (null == blobContent || blobContent.Length == 0)\n', '        {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }    \n', '};\n', '\n', 'class Utils\n', '{\n', '    public static async Task<FuncResult> PostRequest(string url, int numOfTries = 1, string postData = \"\")\n', '    {\n', '        FuncResult result = new FuncResult();\n', '        //Globals._log.LogError($\"Utils.PostRequest - postData: {postData}, tries: {numOfTries}\");\n', '\n', '        while (numOfTries > 0)\n', '        {\n', '            result = await PostRequest(url, postData);\n', '            if (result.status)\n', '            {\n', '                if ((result.other as HttpResponseMessage).StatusCode == HttpStatusCode.OK)\n', '                {\n', '                    break;\n', '                }\n', '            }\n', '            numOfTries--;\n', '            Globals._log.LogInformation($\"Utils.PostRequest - Error during POST [{postData}] to [{url}].\\n{numOfTries} more attempts will be done\");\n', '            Thread.Sleep(1000); // wait 1 sec before next try\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    public static async Task<FuncResult> PutRequest(string url, int numOfTries = 1, string payload = \"\")\n', '    {\n', '        FuncResult result = new FuncResult();\n', '        //Globals._log.LogError($\"Utils.PutRequest - payload: {payload}, tries: {numOfTries}\");\n', '\n', '        while (numOfTries > 0)\n', '        {\n', '            result = await PutRequest(url, payload);\n', '            if (result.status)\n', '            {\n', '                if ((result.other as HttpResponseMessage).StatusCode == HttpStatusCode.OK)\n', '                {\n', '                    break;\n', '                }\n', '            }\n', '            numOfTries--;\n', '            Globals._log.LogInformation($\"Utils.PutRequest - Error during PUT [{payload}] to [{url}].\\n{numOfTries} more attempts will be done\");\n', '            Thread.Sleep(1000); // wait 1 sec before next try\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    // TODO: consider making this function more generic (i.e. add content)\n', '    static async Task<FuncResult> PostRequest(string url, string postData = \"\")\n', '    {\n', '        using ( var handler = new HttpClientHandler() )\n', '        {\n', '            // this will actually validate every server certificate\n', '            // this is the only reason for creating the HTTP handler instance\n', '            handler.ServerCertificateCustomValidationCallback = ( message, cert, chain, errors ) => { return true; };\n', '\n', '            using (var client = new HttpClient(handler))\n', '            {\n', '                // set request''s URL\n', '                client.BaseAddress = new Uri(url);\n', '\n', '                // add basic authentication\n', '                client.DefaultRequestHeaders.Authorization = Globals._authHeader;\n', '                if (null == client.DefaultRequestHeaders.Authorization)\n', '                {\n', '                    string message = \"Error generating authorization header\";\n', '                    Globals._log.LogError($\"Utils.PostRequest - {message}\");\n', '                    return new FuncResult(false, message);\n', '                }\n', '\n', '                // send put-config\n', '                HttpResponseMessage response = await client.PostAsync(\"\", string.IsNullOrEmpty(postData) ? null : new StringContent(postData));\n', '                string responseContent = await response.Content.ReadAsStringAsync();\n', '                if (null == response || response.StatusCode != HttpStatusCode.OK)\n', '                {\n', '                    Globals._log.LogError($\"Utils.PostRequest - bad response content: {responseContent}\");\n', '\n', '                    string message = $\"Received request error from {response.RequestMessage.RequestUri}\";\n', '                    Globals._log.LogError($\"Utils.PostRequest - {message}\");\n', '                    return new FuncResult(false, message);\n', '                }\n', '\n', '                Globals._log.LogInformation($\"Utils.PostRequest - response for [{url}, {postData}]: {responseContent}\");\n', '\n', '                return new FuncResult(true, responseContent, response);\n', '            }\n', '        }\n', '    }\n', '\n', '    // just use POST request for the given URL and content\n', '    public static async Task<HttpResponseMessage> PostUrl(string url, StringContent content)\n', '    {\n', '        using (var handler = new HttpClientHandler())\n', '        {\n', '            // this will actually validate every server certificate\n', '            // this is the only reason for creating the HTTP handler instance\n', '            handler.ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => { return true; };\n', '\n', '            using (var client = new HttpClient(handler))\n', '            {\n', '                client.BaseAddress = new Uri(url);\n', '\n', '                return await client.PostAsync(url, content);\n', '            }\n', '        }\n', '    }\n', '\n', '    // TODO: consider making this function more generic (i.e. add content, merge with PostRequest)\n', '    static async Task<FuncResult> PutRequest(string url, string payload = \"\")\n', '    {\n', '        using ( var handler = new HttpClientHandler() )\n', '        {\n', '            // this will actually validate every server certificate\n', '            // this is the only reason for creating the HTTP handler instance\n', '            handler.ServerCertificateCustomValidationCallback = ( message, cert, chain, errors ) => { return true; };\n', '\n', '            using (var client = new HttpClient(handler))\n', '            {\n', '                // set request''s URL\n', '                client.BaseAddress = new Uri(url);\n', '\n', '                // add basic authentication\n', '                client.DefaultRequestHeaders.Authorization = Globals._authHeader;\n', '                if (null == client.DefaultRequestHeaders.Authorization)\n', '                {\n', '                    string message = \"Error generating authorization header\";\n', '                    Globals._log.LogError($\"Utils.PutRequest - {message}\");\n', '                    return new FuncResult(false, message);\n', '                }\n', '\n', '                // send put-config\n', '                HttpResponseMessage response = await client.PutAsync(\"\", string.IsNullOrEmpty(payload) ? null : new StringContent(payload));\n', '                string responseContent = await response.Content.ReadAsStringAsync();\n', '                if (null == response || response.StatusCode != HttpStatusCode.OK)\n', '                {\n', '                    Globals._log.LogError($\"Utils.PutRequest - bad response content: {responseContent}\");\n', '\n', '                    string message = $\"Received request error from {response.RequestMessage.RequestUri}\";\n', '                    Globals._log.LogError($\"Utils.PutRequest - {message}\");\n', '                    return new FuncResult(false, message);\n', '                }\n', '\n', '                Globals._log.LogInformation($\"Utils.PutRequest - response for [{url}, {payload}]: {responseContent}\");\n', '\n', '                return new FuncResult(true, responseContent, response);\n', '            }\n', '        }\n', '    }\n', '\n', '    // extract the username and password from the request''s data and genetate an authentication header value\n', '    public static System.Net.Http.Headers.AuthenticationHeaderValue GenerateAuthorizationValue()\n', '    {\n', '        // extract the username and password from the request''s body\n', '        string username = Globals._requestData?.username;\n', '        string password = Globals._requestData?.password;\n', '\n', '        if (string.IsNullOrEmpty(username) || string.IsNullOrEmpty(password))\n', '        {\n', '            return null;\n', '        }\n', '\n', '        var byteArray = Encoding.ASCII.GetBytes($\"{username}:{password}\");\n', '        return new System.Net.Http.Headers.AuthenticationHeaderValue(\"Basic\", Convert.ToBase64String(byteArray));\n', '    }\n', '\n', '    // extract ip and port either from the request (remote ip/post data) or by default (port)\n', '    public static string GetCallerAddress(HttpRequest req, Dictionary<string, string> idPortTable)\n', '    {\n', '        // for debugging - i can pass the port number in the request''s data\n', '        string remotePort = Globals._requestData?.accessPort;\n', '        if (string.IsNullOrEmpty(remotePort))\n', '        {\n', '            // default port when using single IP setup\n', '            remotePort = \"8443\";\n', '\n', '            // search for the appropriate port in the given table\n', '            foreach (var kvp in idPortTable)\n', '            {\n', '                // skip initiating Alteon\n', '                if (string.Equals(Globals._instanceId, kvp.Key, StringComparison.OrdinalIgnoreCase))\n', '                {\n', '                    // generate IP from request data and port from the above dictionary\n', '                    remotePort = kvp.Value;\n', '\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '\n', '        string ipAddress = $\"{Globals._remoteIp}:{remotePort}\";\n', '\n', '        return ipAddress;\n', '    }\n', '\n', '    public static Dictionary<string, string> BuildPortsTable(dynamic natRules)\n', '    {\n', '        Dictionary<string, string> ports = new Dictionary<string, string>();\n', '\n', '        // NAT rules response data may look like this:\n', '        /*\n', '        {\n', '            \"value\": [\n', '                {\n', '                    \"name\": \"natRule1.1\",\n', '                    \"id\": \"/subscriptions/subid/resourceGroups/testrg/providers/Microsoft.Network/loadBalancers/lb1/inboundNatRules/natRule1.1\",\n', '                    \"properties\": {\n', '                        \"provisioningState\": \"Succeeded\",\n', '                        \"frontendIPConfiguration\": {\n', '                            \"id\": \"/subscriptions/subid/resourceGroups/testrg/providers/Microsoft.Network/loadBalancers/lb1/frontendIPConfigurations/ip1\"\n', '                        },\n', '                        \"frontendPort\": 3390,\n', '                        \"backendPort\": 3389,\n', '                        \"enableFloatingIP\": false,\n', '                        \"idleTimeoutInMinutes\": 4,\n', '                        \"protocol\": \"Tcp\",\n', '                        \"enableTcpReset\": true,\n', '                        \"backendIPConfiguration\": {\n', '                            \"id\": \"/subscriptions/subid/resourceGroups/testrg/providers/Microsoft.Compute/virtualMachineScaleSets/vmss1/virtualMachines/1/networkInterfaces/nic1/ipConfigurations/ip1\"\n', '                        }\n', '                    }\n', '                },\n', '                {\n', '                    \"name\": \"natRule1.3\",\n', '                    \"id\": \"/subscriptions/subid/resourceGroups/testrg/providers/Microsoft.Network/loadBalancers/lb1/inboundNatRules/natRule1.3\",\n', '                    \"properties\": {\n', '                        \"provisioningState\": \"Succeeded\",\n', '                        \"frontendIPConfiguration\": {\n', '                            \"id\": \"/subscriptions/subid/resourceGroups/testrg/providers/Microsoft.Network/loadBalancers/lb1/frontendIPConfigurations/ip1\"\n', '                        },\n', '                        \"frontendPort\": 3392,\n', '                        \"backendPort\": 3389,\n', '                        \"enableFloatingIP\": false,\n', '                        \"idleTimeoutInMinutes\": 4,\n', '                        \"protocol\": \"Tcp\",\n', '                        \"enableTcpReset\": true,\n', '                        \"backendIPConfiguration\": {\n', '                            \"id\": \"/subscriptions/subid/resourceGroups/testrg/providers/Microsoft.Compute/virtualMachineScaleSets/vmss1/virtualMachines/3/networkInterfaces/nic1/ipConfigurations/ip1\"\n', '                        }\n', '                    }\n', '                }\n', '            ]\n', '        }\n', '        */            \n', '        // go through all the rules and:\n', '        // 1. get the instance rule name (value[i].name)\n', '        // 2. extract it''s id (instance rule name == <rule name>.<id>)\n', '        // 3. get the frontend port (values[i].properties.frontendPort)\n', '        // 4. add id & port to dictionary\n', '\n', '        foreach (var value in natRules.value)\n', '        {\n', '            string rulename = value.name;\n', '            string[] parts = rulename.Split(''.'');\n', '\n', '            if (parts.Length < 2)\n', '            {\n', '                Globals._log.LogError($\"NAT rules response does not contain instance ID: {rulename}\");\n', '                continue;\n', '            }\n', '\n', '            string port = value.properties.frontendPort;\n', '            ports.Add(parts[1], port);\n', '        }\n', '\n', '        Globals._log.LogInformation($\"Utils.BuildPortsTable - [instance id, port number]: {string.Join(\", \", ports)}\");\n', '        return ports;\n', '    }\n', '\n', '};\n', '\n', 'class ClusterSync\n', '{\n', '    // upon ''apply'' command, get the updated configuration from the calling Alteon, save it and update all other\n', '    // Alteons in the cluster\n', '    public static async Task<FuncResult> HandleApplyRequest(HttpRequest req)\n', '    {\n', '        Globals._log.LogInformation($\"ClusterSync.HandleApplyRequest - first collect NAT rules\");\n', '        // get a list of all NAT rules\n', '        dynamic natRules = await AzureInterface.GetInboundNatRules();\n', '        // make a list of instance-ID to port according to nat rules response\n', '        Dictionary<string, string> idPortTable = Utils.BuildPortsTable(natRules);\n', '\n', '        // get the configuration from the calling Alteon\n', '        Globals._log.LogInformation($\"ClusterSync.HandleApplyRequest - get configuration from caller\");\n', '        HttpResponseMessage response = await AlteonInterface.GetConfig(req, idPortTable, 3);\n', '        if (null == response || response.StatusCode != HttpStatusCode.OK)\n', '        {\n', '            string message;\n', '            if (null != response)\n', '            {\n', '                string responseStatus = await response.Content.ReadAsStringAsync();\n', '                Globals._log.LogInformation($\"ClusterSync.HandleApplyRequest - response status: {responseStatus}\");\n', '                \n', '                message = $\"Error {responseStatus} when trying to get Alteon''s configuration (from {response.RequestMessage.RequestUri})\";\n', '            }\n', '            else\n', '            {\n', '                message = \"Unknown error when trying to get Alteon''s configuration\";\n', '            }\n', '            Globals._log.LogError($\"ClusterSync.HandleApplyRequest - {message}\");\n', '            return new FuncResult(false, message);\n', '        }\n', '\n', '        // read the response data\n', '        byte[] responseContent = await response.Content.ReadAsByteArrayAsync();\n', '        // save the configuration received\n', '        await Configuration.Save(responseContent);\n', '        \n', '        // now start the sync process...\n', '\n', '        // now update all other Alteons...\n', '        // TODO: without await i can send all updates together, but (currently) without knowing when it completes\n', '        FuncResult result = await AlteonInterface.UpdateOthers(idPortTable, Globals._instanceId);\n', '\n', '        return result;\n', '    }\n', '\n', '\n', '    // updated the calling Alteon with an updated configuration (if exist)\n', '    public static async Task<FuncResult> HandleFirstApplyRequest(HttpRequest req)\n', '    {\n', '        Globals._log.LogInformation(\"ClusterSync.HandleFirstApplyRequest - calling Azure.GetInboundNatRules\");\n', '\n', '        // get a list of all NAT rules\n', '        dynamic natRules = await AzureInterface.GetInboundNatRules();\n', '        if (null == natRules)\n', '        {\n', '            string message = \"failed to retrieve NAT rules\";\n', '            Globals._log.LogError($\"HandlleFirstApplyRequest - {message}\");\n', '            return new FuncResult(false, message);\n', '        }\n', '\n', '        // make a list of instance-ID to port according to nat rules response\n', '        Dictionary<string, string> idPortTable = Utils.BuildPortsTable(natRules);\n', '        Globals._log.LogInformation($\"ClusterSync.HandleFirstApplyRequest - id-port table:\\n{idPortTable}\");\n', '\n', '        // get the host name/ip from the request\n', '        string address = Utils.GetCallerAddress(req, idPortTable);\n', '        if (string.IsNullOrEmpty(address))\n', '        {\n', '            string message = $\"caller address not found in NAT rules ([instance id, port number]): {string.Join(\", \", idPortTable)}\";\n', '            Globals._log.LogError($\"ClusterSync.HandleFirstApplyRequest - {message}\");\n', '            return new FuncResult(false, message);\n', '        }\n', '\n', '        FuncResult result(true);\n', '\n', '        // if storage is not empty - need to update calling Alteon''s configuration\n', '        Globals._log.LogInformation(\"ClusterSync.HandleFirstApplyRequest - check configuration file existence\");\n', '        if (await Configuration.Exists())\n', '        {\n', '            // use updated configuration to send it back to the requesting Alteon\n', '            result = await AlteonInterface.PutConfig(address, 3);\n', '        }\n', '        else\n', '        {\n', '            Globals._log.LogInformation(\"ClusterSync.HandleFirstApplyRequest - configuration not updated yet\");\n', '\n', '            // add SSL certificate\n', '            // only on first apply, when configuration was not uploaded yet\n', '            await AlteonCertificate.Set(address);\n', '        }\n', '\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '\n', '        // now add license\n', '        result = await AlteonGelLicense.Set(address);\n', '\n', '        return result;\n', '    }\n', '};\n', '\n', '/// a collection of functionalities that handle GEL license\n', 'class AlteonGelLicense\n', '{\n', '    // license related\n', '    static string _licEntitlementIdKey = \"lmLicOperPendingEntitlementId\";\n', '    static string _licThroughputKey = \"lmLicOperThroughput\";\n', '    static string _licSubscriberKey = \"lmLicOperSubscrAddOn\";\n', '    static string _licSyncKey = \"lmLicOperSynclic\";\n', '    static string _licSyncValue = \"0\"; // [0(start)]\n', '\n', '    // translate subscriber value (ignore/perform/secure) to index (0, 2, 3)\n', '    static string SubscriberType(string subscriber)\n', '    {\n', '        if (string.Equals(subscriber, \"Perform\", StringComparison.OrdinalIgnoreCase))\n', '            return \"2\";\n', '\n', '        if (string.Equals(subscriber, \"Secure\", StringComparison.OrdinalIgnoreCase))\n', '            return \"3\";\n', '\n', '        return \"0\";\n', '    }\n', '\n', '    // set license to Alteon (the one sending the first-apply)\n', '    public static async Task<FuncResult> Set(string address)\n', '    {\n', '        string licEntitlementIdValue = Globals._deployParams?.GelLicense.EntitlementId;\n', '        string licThroughputValue = Globals._deployParams?.GelLicense.Throughput;\n', '        string licSubscriberValue = SubscriberType((Globals._deployParams?.GelLicense.Subscriber).ToString());\n', '\n', '        Globals._log.LogInformation($\"AlteonGelLicense.Set - entry\");\n', '\n', '        // to add a license, we should:\n', '        // 1. submit the entitlement id\n', '        // 2. submit the throughput\n', '        // 3. submit subscriber (perform/secure/ignore)\n', '        // 4. commit (sync) license\n', '\n', '        string url = $\"https://{address}/config\";\n', '\n', '        // submit entitlement id\n', '        string postData = $\"{{\\\"{_licEntitlementIdKey}\\\": \\\"{licEntitlementIdValue}\\\"}}\";\n', '        FuncResult result = await Utils.PostRequest(url, 3, postData);\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '\n', '        // submit throughput\n', '        postData = $\"{{\\\"{_licThroughputKey}\\\": \\\"{licThroughputValue}\\\"}}\";\n', '        result = await Utils.PostRequest(url, 3, postData);\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '\n', '        // submit subscriber\n', '        postData = $\"{{\\\"{_licSubscriberKey}\\\": \\\"{licSubscriberValue}\\\"}}\"; // 0/2/3 (ignore/perform/secure)\n', '        result = await Utils.PostRequest(url, 3, postData);\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '\n', '        // now sync\n', '        postData = $\"{{\\\"{_licSyncKey}\\\": \\\"{_licSyncValue}\\\"}}\"; // 0 (start)\n', '        result = await Utils.PostRequest(url, 3, postData);\n', '\n', '        return result;\n', '    }\n', '};\n', '\n', '// a collection of functions to handle SSL certificate injection\n', 'class AlteonCertificate\n', '{\n', '    /// set license to Alteon (the one sending the first-apply)\n', '    public static async Task<FuncResult> Set(string address)\n', '    {\n', '        // 1. set certificate key\n', '        // 2. set certificate data\n', '        Globals._log.LogInformation($\"AlteonCertificate.Set - entry\");\n', '\n', '        // read key and data from parameters file\n', '        string id = Globals._deployParams?.Certificate?.Id;\n', '        string passphrase = Globals._deployParams?.Certificate?.Passphrase;\n', '        string key = Globals._deployParams?.Certificate?.Key;\n', '        string data = Globals._deployParams?.Certificate?.Data;\n', '        bool   isHttpService = Convert.ToBoolean(Globals._deployParams?.Certificate?.SlbHttpService);\n', '        Globals._log.LogWarning($\"AlteonCertificate.Set - http service: {isHttpService}\");\n', '\n', '        if (string.IsNullOrEmpty(data) || string.IsNullOrEmpty(id) || string.IsNullOrEmpty(passphrase))\n', '        {\n', '            // certificate parameters not supplied, but since it''s optional, i''ll return success\n', '            Globals._log.LogError(\"AlteonCertificate.Set - some certificate parameters are missing or empty. No certificate will be applied\");\n', '            return new FuncResult(true);\n', '        }\n', '\n', '        if (string.IsNullOrEmpty(key))\n', '        {\n', '            // data actually contains both key and data - split them\n', '            (key, data) = SplitData(data);\n', '        }\n', '\n', '        if (string.IsNullOrEmpty(data) || string.IsNullOrEmpty(key))\n', '        {\n', '            // certificate key or data were not extracted\n', '            Globals._log.LogError(\"AlteonCertificate.Set - failed to extract either certificate data or certificate key. Please verify the given certificate\");\n', '            return new FuncResult(false);\n', '        }\n', '\n', '        Globals._log.LogInformation($\"AlteonCertificate.Set - key size: {key.Length}, data size: {data.Length}\");\n', '\n', '        // inject key\n', '        string url = $\"https://{address}/config/sslcertimport?renew=0&renewK=0&id={id}&type=key&src=txt&passphrase={passphrase}\";\n', '        FuncResult result = await Utils.PostRequest(url, 3, key);\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '\n', '        // inject data\n', '        url = $\"https://{address}/config/sslcertimport?renew=0&renewK=0&id={id}&type=cert&src=txt\";\n', '        result = await Utils.PostRequest(url, 3, data);\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '\n', '        // before apply, virt 1 needs to be enabled\n', '        string virtId = \"1\";\n', '        /*\n', '        result = await AlteonInterface.EnableVirt(address, virtId);\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '        */\n', '\n', '        // also before apply, virt 1 https service needs it''s certificate defined\n', '        string rPort = Globals._deployParams?.Certificate?.HttpsRport;\n', '        string policyName = Globals._deployParams?.Certificate?.Policy;\n', '        if (string.IsNullOrEmpty(policyName) || string.IsNullOrEmpty(rPort))\n', '        {\n', '            Globals._log.LogInformation(\"AlteonCertificate.Set - notice: no policy or https port defined so VIRT configuration will not be complete\");\n', '            return result;\n', '        }\n', '\n', '        int serviceIndex = isHttpService ? 2 : 1; // assuming HTTP is there as index 1, HTTPS''s index is 2\n', '        Globals._log.LogWarning($\"AlteonCertificate.Set - index set to: {serviceIndex}\");\n', '        result = await AlteonInterface.SetVirtSslCertificateNPolicy(address, rPort, virtId, serviceIndex, id, policyName);\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '\n', '        result = await AlteonInterface.ApplyConfig(address);\n', '\n', '        return result;\n', '    }\n', '\n', '    static (string, string) SplitData(string raw)\n', '    {\n', '        if (string.IsNullOrEmpty(raw))\n', '        {\n', '            Globals._log.LogError(\"AzureCertificate.SplitRaw - certificate is empty\");\n', '            return (\"\", \"\");\n', '        }\n', '        \n', '        // data section starts with -----BEGIN CERTIFICATE----- line\n', '        // and ends with -----END CERTIFICATE----- line\n', '        string dataBegin = \"-----BEGIN CERTIFICATE-----\";\n', '        string dataEnd = \"-----END CERTIFICATE-----\";\n', '        int dataStartPos = raw.IndexOf(dataBegin);\n', '        int dataEndPos = raw.IndexOf(dataEnd);\n', '        if (dataStartPos < 0 || dataEndPos < 0)\n', '        {\n', '            Globals._log.LogError($\"AzureCertificate.SplitRaw - can''t find certificate data section in {raw}\");\n', '            return (\"\", \"\");\n', '        }\n', '        string data = raw.Substring(dataStartPos, dataEndPos + dataEnd.Length - dataStartPos);\n', '\n', '        // key section starts with -----BEGIN RSA PRIVATE KEY----- line\n', '        // and ends with -----END RSA PRIVATE KEY----- line\n', '        string keyBegin = \"-----BEGIN RSA PRIVATE KEY-----\";\n', '        string keyEnd = \"-----END RSA PRIVATE KEY-----\";\n', '        int keyStartPos = raw.IndexOf(keyBegin);\n', '        int keyEndPos = raw.IndexOf(keyEnd);\n', '        if (keyStartPos < 0 || keyEndPos < 0)\n', '        {\n', '            Globals._log.LogError($\"AzureCertificate.SplitRaw - can''t find certificate key section in {raw}\");\n', '            return (\"\", data);\n', '        }\n', '        string key = raw.Substring(keyStartPos, keyEndPos + keyEnd.Length - keyStartPos);\n', '\n', '        return (key, data);\n', '    }\n', '};\n', '\n', '// a collection of functions to interact with Azure\n', 'class AzureInterface\n', '{\n', '    static string _token = \"\";\n', '\n', '    public static void Init()\n', '    {\n', '        _token = \"\";\n', '    }\n', '\n', '    // build the REST API to get a list of NAT rules for a specific Scale Set\n', '    static string GenerateNatRulesListUrl()\n', '    {\n', '        //string subscriptionId = Globals._requestData?.subscriptionId;\n', '        //string resourceGroup = Globals._requestData?.resourceGroupName;\n', '        string subscriptionId = Globals._deployParams?.Azure.SubscriptionId;\n', '        string resourceGroup = Globals._deployParams?.Azure.ResourceGroupName;\n', '        string apiVersion = \"2018-08-01\";\n', '\n', '        return $\"https://management.azure.com/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Network/loadBalancers/{Globals._lbName}/inboundNatRules?api-version={apiVersion}\";\n', '    }\n', '\n', '    // each NAT rule also reflects a VM in the cluster, so i''m actually getting the cluster VMs as well\n', '    public static async Task<dynamic> GetInboundNatRules()\n', '    {\n', '        Globals._log.LogInformation(\"Azure.GetInboundNatRules - entry\");\n', '        // generate the appropriate URL\n', '        string queryUrl = GenerateNatRulesListUrl();\n', '\n', '        // send GET request to ARM to retrieve NAT rules\n', '        HttpResponseMessage response = await GetHttpResponse(queryUrl);\n', '\n', '        string responseContent = await response.Content.ReadAsStringAsync();\n', '        //Globals._log.LogInformation($\"Azure.GetInboundNatRules - response: {responseContent}\");\n', '\n', '        return JsonConvert.DeserializeObject(responseContent);\n', '    }\n', '\n', '    // send http request to ARM and return the response message\n', '    static async Task<HttpResponseMessage> HttpResponse(string method, string url)\n', '    {\n', '        Globals._log.LogInformation($\"AzureInterface.HttpResponse - request: [{method}, {url}]\");\n', '        // first get an authorization token\n', '        // TODO: handle a global token with expiration mechanism\n', '        if (string.IsNullOrEmpty(_token))\n', '        {\n', '            _token = await GetToken();\n', '        }\n', '\n', '        using (var handler = new HttpClientHandler())\n', '        {\n', '            // this will actually validate every server certificate\n', '            // this is the only reason for creating the HTTP handler instance\n', '            handler.ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => { return true; };\n', '\n', '            using (var client = new HttpClient(handler))\n', '            {\n', '                client.BaseAddress = new Uri(url);\n', '                client.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {_token}\");\n', '\n', '                HttpResponseMessage response = null;\n', '                if (string.Equals(method, \"Get\", StringComparison.OrdinalIgnoreCase))\n', '                {\n', '                    response = await client.GetAsync(\"\");\n', '                }\n', '                else // i assume ''Post''\n', '                {\n', '                    response = await client.PostAsync(\"\", null);\n', '                }\n', '\n', '                if (response.StatusCode != HttpStatusCode.OK)\n', '                {\n', '                    Globals._log.LogError($\"Azure.HttpResponse - bad [{method}] response [{response.StatusCode}] for [{url}]:\\n{response.ToString()}\");\n', '                }\n', '\n', '                return response;\n', '            }\n', '        }\n', '    }\n', '\n', '    // send get request to ARM and return the response message\n', '    public static async Task<HttpResponseMessage> GetHttpResponse(string url)\n', '    {\n', '        HttpResponseMessage response = await HttpResponse(\"Get\", url);\n', '        return response;\n', '    }\n', '\n', '    // send post request to ARM and return the response message\n', '    public static async Task<HttpResponseMessage> PostHttpResponse(string url)\n', '    {\n', '        HttpResponseMessage response = await HttpResponse(\"Post\", url);\n', '        return response;\n', '    }\n', '\n', '    // get an authorization token from ARM\n', '    static async Task<string> GetToken()\n', '    {\n', '        // ask for token using the given credentials\n', '        //string tenantId = Globals._requestData?.tenantId;\n', '        //string clientId = Globals._requestData?.clientId;\n', '        //string clientSecret = Globals._requestData?.clientSecret;\n', '        string tenantId = Globals._deployParams?.Azure.TenantId;\n', '        string clientId = Globals._deployParams?.Azure.ClientId;\n', '        string clientSecret = Globals._deployParams?.Azure.ClientSecret;\n', '\n', '        // request a token\n', '        string url = $\"https://login.windows.net/{tenantId}/oauth2/token\";\n', '\n', '        string resourceData = $\"https://management.core.windows.net/&client_id={clientId}&grant_type=client_credentials&client_secret={clientSecret}\";\n', '        StringContent content = new StringContent($\"resource={resourceData}\", Encoding.UTF8, \"application/x-www-form-urlencoded\");\n', '\n', '        HttpResponseMessage response = await Utils.PostUrl(url, content);\n', '\n', '        string responseContent = await response.Content.ReadAsStringAsync();\n', '\n', '        // extract the token from the response\n', '        dynamic resData = JsonConvert.DeserializeObject(responseContent);\n', '        string token = resData?.access_token;\n', '        Globals._log.LogInformation($\"Azure.GetToken - response: {token}\");\n', '\n', '        return token;\n', '    }\n', '};\n', '\n', '// a collection of functions to interact with Alteon\n', 'class AlteonInterface\n', '{\n', '    public static async Task<HttpResponseMessage> GetConfig(HttpRequest req, Dictionary<string, string> idPortTable, int numOfTries)\n', '    {\n', '        HttpResponseMessage response = null;\n', '\n', '        // get the host name/ip from the request\n', '        string ipAddress = Utils.GetCallerAddress(req, idPortTable);\n', '        string url = $\"https://{ipAddress}/config/getcfg?pkey=yes\";\n', '        Globals._log.LogInformation($\"Alteon.GetConfig - going to query {url}\");\n', '\n', '        while (numOfTries > 0)\n', '        {\n', '            response = await GetConfig(url);\n', '            if (null != response && response.StatusCode == HttpStatusCode.OK)\n', '            {\n', '                // success\n', '                break;\n', '            }\n', '            numOfTries--;\n', '            Globals._log.LogInformation($\"Alteon.GetConfig - Error during Get-Config, {numOfTries} more attempts will be done\");\n', '            Thread.Sleep(1000); // wait 1 sec before next try\n', '        }\n', '\n', '        return response;\n', '    }\n', '\n', '    // generic get-config method - send get-config request to Alteon VM\n', '    public static async Task<HttpResponseMessage> GetConfig(string url)\n', '    {\n', '        try\n', '        {\n', '            using ( var handler = new HttpClientHandler() )\n', '            {\n', '                // this will actually validate every server certificate\n', '                // this is the only reason for creating the HTTP handler instance\n', '                handler.ServerCertificateCustomValidationCallback = ( message, cert, chain, errors ) => { return true; };\n', '\n', '                using (var client = new HttpClient(handler))\n', '                {\n', '                    // add basic authentication\n', '                    client.DefaultRequestHeaders.Authorization = Globals._authHeader;\n', '                    if (null == client.DefaultRequestHeaders.Authorization)\n', '                    {\n', '                        string message = \"Alteon.GetConfig - Error generating authorization header\";\n', '                        Globals._log.LogError(message);\n', '                        return null;\n', '                    }\n', '\n', '                    client.DefaultRequestHeaders.Add(\"Passphrase\", Globals._passphrase);\n', '\n', '                    client.BaseAddress = new Uri(url);\n', '                    HttpResponseMessage response = await client.GetAsync(\"\");\n', '\n', '                    Globals._log.LogInformation($\"Alteon.GetConfig - response: {response}\");\n', '\n', '                    return response;\n', '                }\n', '            }\n', '        }\n', '        catch (Exception ex)\n', '        {\n', '            Globals._log.LogError($\"Alteon.GetConfig - an exception occured. Request URL: {url}\\nException: {ex.ToString()}\");\n', '            return null;\n', '        }\n', '    }\n', '\n', '    public static async Task<FuncResult> PutConfig(string address, int numOfTries)\n', '    {\n', '        FuncResult result = new FuncResult(false, \"\");\n', '\n', '        while (numOfTries > 0)\n', '        {\n', '            result = await PutConfig(address);\n', '            if (result.status)\n', '            {\n', '                break;\n', '            }\n', '            numOfTries--;\n', '            Globals._log.LogInformation($\"Alteon.PutConfig - Error during Put-Config, {numOfTries} more attempts will be done\");\n', '            Thread.Sleep(1000); // wait 1 sec before next try\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    // generic put-config method - use given configuration file and send it to an Alteon VM\n', '    static async Task<FuncResult> PutConfig(string address)\n', '    {\n', '        string url = $\"https://{address}/config/configimport?pkey=yes\";\n', '        Globals._log.LogInformation($\"Alteon.PutConfig - going to put config to {url}\");\n', '\n', '        try\n', '        {\n', '            using ( var handler = new HttpClientHandler() )\n', '            {\n', '                // this will actually validate every server certificate\n', '                // this is the only reason for creating the HTTP handler instance\n', '                handler.ServerCertificateCustomValidationCallback = ( message, cert, chain, errors ) => { return true; };\n', '\n', '                using (var client = new HttpClient(handler))\n', '                {\n', '                    // set request''s URL\n', '                    client.BaseAddress = new Uri(url);\n', '\n', '                    // add basic authentication\n', '                    client.DefaultRequestHeaders.Authorization = Globals._authHeader;\n', '                    if (null == client.DefaultRequestHeaders.Authorization)\n', '                    {\n', '                        string message = \"Error generating authorization header\";\n', '                        Globals._log.LogError($\"Alteon.PutConfig - {message}\");\n', '                        return new FuncResult(false, message);\n', '                    }\n', '\n', '                    Globals._log.LogInformation($\"Alteon.PutConfig - authorization added: {client.DefaultRequestHeaders.Authorization.ToString()}\");\n', '\n', '                    client.DefaultRequestHeaders.Add(\"Passphrase\", Globals._passphrase);\n', '\n', '                    using (var content = new MultipartFormDataContent())\n', '                    {\n', '                        /*\n', '                        it makes sense to use a one-time-created value to add to the request''s content, as this\n', '                        value would be created once outside this function and be reused in consequtive calls.\n', '                        apparently, after each request, this value is disposed, so i need to create it every\n', '                        time when creating a new request :-(\n', '                        */\n', '                        ByteArrayContent configFile = await Configuration.GetContent();\n', '                        if (null == configFile)\n', '                        {\n', '                            return new FuncResult(false, \"Alteon.PutConfig - couldn''t get a valid configuration\");\n', '                        }\n', '                        content.Add(configFile);\n', '\n', '                        // send put-config\n', '                        HttpResponseMessage response = await client.PostAsync(\"\", content);\n', '                        Globals._log.LogInformation($\"Alteon.PutConfig - response: {response.ToString()}\");\n', '                        string responseContent = await response.Content.ReadAsStringAsync();\n', '                        Globals._log.LogInformation($\"Alteon.PutConfig - response content: {responseContent}\");\n', '\n', '                        if (response.StatusCode != HttpStatusCode.OK)\n', '                        {\n', '                            string message = $\"Error {responseContent} when trying to put-config to {url}\";\n', '                            Globals._log.LogError($\"Alteon.PutConfig - {message}\");\n', '                            return new FuncResult(false, message);\n', '                        }\n', '\n', '                        // now send apply to that Alteon\n', '                        FuncResult result = await ApplyConfig(address);\n', '                        Globals._log.LogInformation($\"Alteon.PutConfig - result of apply: {result}\");\n', '\n', '                        return new FuncResult(true, responseContent);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        catch (Exception ex)\n', '        {\n', '            Globals._log.LogError($\"Alteon.PutConfig - an exception occured. Request URL: {url}\\nException: {ex.ToString()}\");\n', '            return new FuncResult(false, \"\");\n', '        }\n', '    }\n', '\n', '    // go through all existing Alteons and sent put-config request to them (skip the originating Alteon)\n', '    public static async Task<FuncResult> UpdateOthers(Dictionary<string, string> instancesPorts, string instanceId)\n', '    {\n', '        FuncResult result = new FuncResult();\n', '        int successfulApplys = 0;\n', '        int totalApplys = 0;\n', '\n', '        Globals._log.LogInformation(\"Alteon.UpdateOthers - enter\");\n', '\n', '        foreach (KeyValuePair<string, string> kvp in instancesPorts)\n', '        {\n', '            // skip initiating Alteon\n', '            if (string.Equals(instanceId, kvp.Key, StringComparison.OrdinalIgnoreCase))\n', '            {\n', '                continue;\n', '            }\n', '            // generate IP from request data and port from the above dictionary\n', '            string address = $\"{Globals._remoteIp}:{kvp.Value}\";\n', '            Globals._log.LogInformation($\"Alteon.UpdateOthers - handling address {address}\");\n', '\n', '            result = await PutConfig(address, 3);\n', '            if (result.status)\n', '            {\n', '                successfulApplys += 1;\n', '            }\n', '            totalApplys += 1;\n', '        }\n', '\n', '        result.status = true;\n', '        result.message = $\"successfully applied {successfulApplys} VMs out of {totalApplys} tries\";\n', '        return result;\n', '    }\n', '\n', '    // set ''virt 1'' as enabled\n', '    public static async Task<FuncResult> EnableVirt(string address, string virtId)\n', '    {\n', '        string url = $\"https://{address}/config/SlbNewCfgEnhVirtServerTable/{virtId}/\";\n', '\n', '        // add payload. server state 2 means enable\n', '        string payload = $\"{{\\\"VirtServerState\\\":\\\"2\\\",\\\"VirtServerIndex\\\":\\\"{virtId}\\\"}}\";\n', '\n', '        FuncResult result = await Utils.PutRequest(url, 3, payload);\n', '\n', '        return result;\n', '    }\n', '\n', '    // add certificate id and policy id to virt 1 (virt id), https service (service id)\n', '    public static async Task<FuncResult> SetVirtSslCertificateNPolicy(string address, string rPort, string virtId, int serviceIndex, string certificateName, string policyName)\n', '    {\n', '        string url = $\"https://{address}/config/SlbNewCfgEnhVirtServicesSecondPartTable/{virtId}/{serviceIndex}/\";\n', '        // add payload\n', '        string payload = $\"{{\\n\\\"ServCert\\\":\\\"{certificateName}\\\",\\n\\\"SSLpol\\\":\\\"{policyName}\\\"\\n}}\";\n', '\n', '        FuncResult result = await Utils.PutRequest(url, 3, payload);\n', '\n', '        return result;\n', '    }\n', ' \n', '\n', '    public static async Task<FuncResult> ApplyConfig(string address)\n', '    {\n', '        Globals._log.LogInformation(\"Alteon.ApplyConfig - entry\");\n', '        \n', '        string url = $\"https://{address}/config?action=clusterSyncApply\";\n', '\n', '        return await Utils.PostRequest(url);\n', '    }\n', '};\n', '\n', '//public static async Task<IActionResult> Run(HttpRequest req, CloudBlockBlob blob, ILogger log, Microsoft.Azure.WebJobs.ExecutionContext context)\n', 'public static async Task<IActionResult> Run(HttpRequest req, ILogger log, Microsoft.Azure.WebJobs.ExecutionContext context)\n', '{\n', '    string reqMethod = req.Method;\n', '    log.LogInformation($\"C# HTTP trigger function processing a {reqMethod} request.\");\n', '    if (!string.Equals(reqMethod, \"post\", StringComparison.OrdinalIgnoreCase))\n', '    {\n', '        return new BadRequestObjectResult(\"Please use a POST request when using this function\");\n', '    }\n', '\n', '    // simple logic:\n', '    // 1. if first apply and storage contains a configuration -\n', '    //    - put configuration from storage to Alteon\n', '    // 2. if apply -\n', '    //    - get configuration from Alteon\n', '    //    - save configuration to storage\n', '    //    - populate configuration too all other Alteons in the set\n', '    // x. if first apply and configuration storage is empty (we don''t really need this) -\n', '    //    - get configuration from Alteon\n', '    //    - store the configuration in cloud storage\n', '    //    - populate configuration to all other Alteons in the set\n', '\n', '    // set some globals\n', '    //bool res = await Globals.Init(req, blob, log, context);\n', '    bool res = await Globals.Init(req, log, context);\n', '    if (res)\n', '    {\n', '        // extract first apply indication from request body\n', '        string firstApply = Globals._requestData?.firstApply;\n', '\n', '        // indication must exist\n', '        if (!string.IsNullOrEmpty(firstApply))\n', '        {\n', '            // check for first apply indication\n', '            if (string.Equals(firstApply, \"true\", StringComparison.OrdinalIgnoreCase))\n', '            {\n', '                var result = await ClusterSync.HandleFirstApplyRequest(req);\n', '                Globals._log.LogInformation($\"ClusterSync.HandleFirstApplyRequest returned {result.ToString()}\");\n', '\n', '                return (ActionResult)new OkObjectResult($\"ClusterSync.HandleFirstApplyRequest result: {result.ToString()}\");\n', '            }\n', '            // check for apply indication (first apply is false)\n', '            else if (string.Equals(firstApply, \"false\", StringComparison.OrdinalIgnoreCase))\n', '            {\n', '                var result = await ClusterSync.HandleApplyRequest(req);\n', '                Globals._log.LogInformation($\"HandleApplyRequest returned {result.ToString()}\");\n', '\n', '                return (ActionResult)new OkObjectResult($\"apply, put-config result: {result.ToString()}\");\n', '            }\n', '            else\n', '            {\n', '                return new BadRequestObjectResult(\"Please pass a valid value (true/false) for ''firstApply'' indication in the request body\");\n', '            }\n', '        }\n', '        else\n', '        {\n', '            return new BadRequestObjectResult(\"Please pass a ''firstApply'' indication on the query string or in the request body\");\n', '        }\n', '    }\n', '\n', '    return new BadRequestObjectResult(\"Failed extracting required values from request''s data\");\n', '}\n')]",
                "function_params.json" : "[variables('azureFunctionJsonParams')]"

              }
            }
          }
       ]                        
    },
    {
        "type": "Microsoft.Web/sites/hostNameBindings",
        "name": "[concat(parameters('alteonsAzureFuncName'), '/', parameters('alteonAzureFuncHostNameBindingsName'))]",
        "apiVersion": "2018-02-01",
        "location": "[parameters('location')]",
        "scale": null,
        "properties": {
            "siteName": "[parameters('alteonsAzureFuncName')]",
            "domainId": null,
            "hostNameType": "Verified"
        },
        "dependsOn": [
            "[resourceId('Microsoft.Web/sites', parameters('alteonsAzureFuncName'))]"
        ]
    }    
],
"outputs": {
    "alteonsAzureFuncName": {
        "type": "String",
        "value": "[listsecrets(resourceId('Microsoft.Web/sites/functions', parameters('alteonsAzureFuncName'), 'TestFunctionCM'),'2016-08-01').trigger_url]"
    }
}
}