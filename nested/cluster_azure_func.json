{
    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {
        "location": {
			"defaultValue": "[resourceGroup().location]",
            "type": "String"
        },
        "alteonsAzureFuncName": { 
			"defaultValue": "func",
            "type": "String"
        },
        "alteonAzureFuncServerfarmsPlanName": { 
			"defaultValue": "serverfarmname",
            "type": "String"
        },
        "alteonsAzureFuncServerFarmId": { 
			"defaultValue": "serverfarm",
            "type": "String"
        },        
        "storageAccountName": { 
			"defaultValue": "storageaccountname",
            "type": "String"
        },
        "storageAccountType": { 
			"defaultValue": "storageaccounttype",
            "type": "String"
        },        
        "blobContainerName": { 
			"defaultValue": "blobcontainername",
            "type": "String"
        },
        "alteonAzureFuncHostNameBindingsName": {
        "defaultValue": "hostbindingname",
           "type": "String"
        },  
        "alteonAzureFuncParams": {
            "type": "object",
            "metadata": {
                "description": "" 
            }
        }                                                                                              
    }, 
    "variables":
    {
        "azureFunctionJsonParams": "[concat('{\n\t\"Azure\":\n\t{\n\t\t\"LoadBalancerName\":', '\"', parameters('alteonAzureFuncParams').Azure.loadBalancersName, '\",', '\n\t\t\"SubscriptionId\":', '\"', parameters('alteonAzureFuncParams').Azure.SubscriptionId, '\",', '\n\t\t\"TenantId\":', '\"', parameters('alteonAzureFuncParams').Azure.TenantID, '\",', '\",', '\n\t\t\"ClientId\":', '\"', parameters('alteonAzureFuncParams').Azure.ClientID, '\",', '\",', '\n\t\t\"ClientSecret\":', '\"', parameters('alteonAzureFuncParams').Azure.ClientSecret, '\",', '\",', '\n\t\t\"ResourceGroupName\":', '\"', parameters('alteonAzureFuncParams').Azure.resourceGroupName, '\"\n\t},', '\n\t\"GelLicense\":\n\t{\n\t\t\"EntitlementId\": \"', parameters('alteonAzureFuncParams').Gel.EntitlementId, '\",',   '\n\t\t\"Throughput\": \"', parameters('alteonAzureFuncParams').Gel.ThroughputLicense, '\",',   '\n\t\t\"Subscriber\": \"', parameters('alteonAzureFuncParams').Gel.AddOnSubsciption, '\"\n\t},',    '\n\t\"Certificate\":\n\t{\n\t\t\"id\": \"', parameters('alteonAzureFuncParams').Ssl.Id, '\",',   '\n\t\t\"Passphrase\": \"', parameters('alteonAzureFuncParams').Ssl.SslPrivateKeyPassphrase, '\",',   '\n\t\t\"Data\": \"', parameters('alteonAzureFuncParams').Ssl.sslCertNkeyFile, '\"\n\t}   \n}')]"
    },
    "resources": [    
    {
        "type": "Microsoft.Storage/storageAccounts",
        "name": "[parameters('storageAccountName')]",
        "apiVersion": "2018-07-01",
        "location": "[parameters('location')]",
        "kind": "BlobStorage",
        "sku": {
            "name": "[parameters('storageAccountType')]",
            "tier": "Standard"
        },
        "properties": 
        {
            "accessTier": "Hot"
        },
        "resources": [
            {
                "name": "[concat('default/', parameters('blobContainerName'))]",
                "type": "blobServices/containers",
                "apiVersion": "2018-03-01-preview",
                "dependsOn": [
                    "[parameters('storageAccountName')]"
                ],
                "properties": {
                "publicAccess": "None"
                }                   
            }  
        ]            
    },         
    {
        "type": "Microsoft.Web/serverfarms",
        "sku": {
            "name": "Y1",
            "tier": "Dynamic",
            "size": "Y1",
            "family": "Y",
            "capacity": 0
        },
        "kind": "functionapp",
        "name": "[parameters('alteonAzureFuncServerfarmsPlanName')]",
        "apiVersion": "2017-08-01",
        "location": "[parameters('location')]",
        "scale": null,
        "properties": {
            "name": "[parameters('alteonAzureFuncServerfarmsPlanName')]",
            "workerTierName": null,
            "adminSiteName": null,
            "hostingEnvironmentProfile": null,
            "perSiteScaling": false,
            "reserved": false,
            "targetWorkerCount": 0,
            "targetWorkerSizeId": 0
        },
        "dependsOn": []
    },      
    {
        "type": "Microsoft.Web/sites",
        "kind": "functionapp",
        "name": "[parameters('alteonsAzureFuncName')]",
        "apiVersion": "2016-08-01",
        "location": "[parameters('location')]",
        "scale": null,
        "properties": {

            "serverFarmId": "[parameters('alteonsAzureFuncServerFarmId')]",
            "reserved": false,
            "siteConfig": null,
            "scmSiteAlsoStopped": false,
            "hostingEnvironmentProfile": null,
            "clientAffinityEnabled": false,
            "clientCertEnabled": false,
            "hostNamesDisabled": false,
            "containerSize": 1536,
            "dailyMemoryTimeQuota": 0,
            "cloningInfo": null
        },
        "dependsOn": [
            "[resourceId('Microsoft.Web/serverfarms', parameters('alteonAzureFuncServerfarmsPlanName'))]"
        ],
        "resources": [           
            {
                "apiVersion": "2018-02-01",
                "name": "appsettings",
                "type": "config",
                "dependsOn": [
                    "[resourceId('Microsoft.Web/sites', parameters('alteonsAzureFuncName'))]",
                    "[parameters('storageAccountName')]"
                ],
                "properties": {
                    "AzureWebJobsStorage": "[concat('DefaultEndpointsProtocol=https;AccountName=',parameters('storageAccountName'),';AccountKey=',listkeys(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), '2018-02-01').keys[0].value)]", 
                    "AzureWebJobsDashboardWEBSITE_CONTENTAZUREFILECONNECTIONSTRING": "[concat('DefaultEndpointsProtocol=https;AccountName=',parameters('storageAccountName'),';AccountKey=',listkeys(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), '2018-02-01').keys[0].value)]", 
                    "FUNCTIONS_EXTENSION_VERSION": "~2",
                    "AzureWebJobsSecretStorageType": "Files"
                }
            },
            {
            "apiVersion": "2018-02-01",
            "name": "TestFunctionCM",
            "type": "functions",
            "dependsOn": [
                "[resourceId('Microsoft.Web/sites', parameters('alteonsAzureFuncName'))]"
            ],
            "properties": {
                "config": {
                    "bindings": [
                        {
                          "authLevel": "anonymous",
                          "name": "req",
                          "type": "httpTrigger",
                          "direction": "in"
                        },
                        {
                          "name": "res",
                          "type": "http",
                          "direction": "out"
                        },
                        {
                          "name": "blob",
                          "type": "blob",
                          "direction": "in",
                          "path": "alteonconfig/clusterConfiguration.tgz",
                          "connection": "AzureWebJobsStorage"
                        }
                      ]    
              },
              "files": {
                "run.csx":  "[concat('#r \"Newtonsoft.Json\"\n', '#r \"System.Web\"\n', '#r \"System.Threading\"\n', '#r \"Microsoft.WindowsAzure.Storage\"\n', '\n', '\n', 'using System.IO;\n', 'using Microsoft.AspNetCore.Mvc;\n', 'using Microsoft.Azure.WebJobs;\n', 'using Microsoft.AspNetCore.Http;\n', 'using Microsoft.Azure.WebJobs.Host;\n', 'using Newtonsoft.Json;\n', 'using Microsoft.Extensions.Logging;\n', '\n', 'using Microsoft.Extensions.Primitives;\n', 'using Microsoft.WindowsAzure.Storage.Blob;\n', '\n', 'using System.Threading.Tasks;\n', 'using System;\n', 'using System.Net;\n', 'using System.Net.Http;\n', 'using System.Net.Http.Headers;\n', 'using System.Web;\n', 'using System.Text;\n', 'using System.Threading;\n', '\n', 'using System.Collections.Generic;\n', '\n', '/*\n', 'TODO 1: delete old commented code\n', 'TODO 2: it should be possible to unite several functions/remove code duplications (i.e. AlteonPostRequest/AlteonGetRequest)\n', 'TODO 3: consider separating the AlteonApplyConfig from AlteonPutConfig (and retries separately on put and apply)\n', 'TODO 4: errors handling (timeouts, non OK responses, etc.)\n', 'TODO 5: through all this code, i don''t verify existence of correct post data. in case some are missing, behavior is unexpected\n', '{\n', '    \"firstApply\": \"false\",\n', '    \"username\": \"admin\",\n', '    \"password\": \"admin\",\n', '    \"passphrase\": \"radware\",\n', '    \"tenantId\": \"36361a21-c721-4248-9748-8848b2573f18\",\n', '    \"clientId\": \"0c46a7db-cf3d-475d-ab18-e0601a94fde5\",\n', '    \"clientSecret\": \"OvPYiakHZ9WFRres6dLAtub54Y52LO3WeEqKzrCEVys=\",\n', '    \"subscriptionId\": \"6c5564e0-54db-4d63-aa7b-1a7d78dd6f98\",\n', '    \"resourceGroup\": \"demoAlteonCluster999\",\n', '    \"instanceName\": \"demoAlteonCluster999Vmss_1\",\n', '    \"accessIp\": \"168.61.40.73\", // used for testing\n', '    \"accessPort\": \"8443\",       // used for testing\n', '}\n', '*/\n', '\n', 'class Globals\n', '{\n', '    // some public global variables\n', '    public static string   _localPath = @\"D:\\home\\site\\wwwroot\\TestFunctionCM\";\n', '    public static string   _remoteIp = \"\";\n', '    public static string   _passphrase = \"\";\n', '    public static string   _lbName = \"\";\n', '    public static string   _instanceId = \"\";\n', '    public static dynamic  _requestData = null;\n', '    public static dynamic  _deployParams = null;\n', '    public static ILogger  _log = null;\n', '    public static System.Net.Http.Headers.AuthenticationHeaderValue _authHeader = null;\n', '\n', '\n', '    public static async Task<bool> Set(HttpRequest req, CloudBlockBlob blob, ILogger log)\n', '    {\n', '        Blob._blob = blob;\n', '        Globals._log = log;\n', '        string requestBody = await new StreamReader(req.Body).ReadToEndAsync();\n', '        _requestData = JsonConvert.DeserializeObject(requestBody);\n', '        log.LogInformation($\"extracting global data from: {_requestData}\");\n', '        _authHeader = Utils.GenerateAuthorizationValue();\n', '        _passphrase = ExtractCallerPassphrase();\n', '        (string name, string id) result =  ExtractInstanceId(); // extract scaleset name and Alteon''s instance ID\n', '        //_lbName = $\"{result.name}LB\";\n', '        _instanceId = result.id;\n', '        // this is for testing only (i.e. when using postman)\n', '        _remoteIp = _requestData?.accessIp; // does not exist when sent from Alteon\n', '        if (string.IsNullOrEmpty(_remoteIp))\n', '        {\n', '            _remoteIp = req.HttpContext.Connection.RemoteIpAddress.ToString();\n', '        }\n', '        log.LogInformation($\"remote ip: {_remoteIp}\");\n', '\n', '        string deployParams = System.IO.File.ReadAllText($@\"{Globals._localPath}\\params.json\");\n', '        _deployParams = \"zionzion', '\"; //JsonConvert.DeserializeObject(deployParams);\n', '\n', '        _lbName = _deployParams?.Azure.LoadBalancerName;\n', '        log.LogInformation($\"Globals - lbName: {_lbName}\");\n', '\n', '        return true;\n', '    }\n', '\n', '    static string ExtractCallerPassphrase()\n', '    {\n', '        // extract the passphrase from the request data\n', '        string passphrase = _requestData?.passphrase;\n', '        if (string.IsNullOrEmpty(passphrase))\n', '        {\n', '            return \"radware\";\n', '        }\n', '        \n', '        return passphrase;\n', '    }\n', '\n', '    public static (string name, string id) ExtractInstanceId()\n', '    {\n', '        // extract instance ID from the instance Name (<instance>_<id>)\n', '        string instanceName = _requestData?.instanceName;\n', '        if (string.IsNullOrEmpty(instanceName))\n', '        {\n', '            _log.LogError(\"request does not contain instance name\");\n', '            return (\"\", \"\");\n', '        }\n', '\n', '        string[] parts = instanceName.Split(''_'');\n', '        if (parts.Length < 2)\n', '        {\n', '            _log.LogError(\"request contain instance name but not instance ID\");\n', '            return (\"\", \"\");\n', '        }\n', '\n', '        return (parts[0], parts[1]);\n', '    }\n', '};\n', '\n', 'class FuncResult\n', '{\n', '    public FuncResult(bool status = false, string message = \"\", object other = null)\n', '    {\n', '        this.status = status;\n', '        this.message = message;\n', '        this.other = other;\n', '    }\n', '\n', '    public bool status {get; set;}\n', '    public string message {get; set;}\n', '    public object other {get; set;}\n', '};\n', '\n', 'class Configuration\n', '{\n', '    public static async Task<bool> Exists()\n', '    {\n', '        return await Blob.Exists();\n', '    }\n', '\n', '    // read configuration file and save it to storage (used after get-config request)\n', '    public static async Task<bool> Save(byte[] responseContent)\n', '    {\n', '        await Blob.PutBuffer(responseContent);\n', '        Globals._log.LogInformation($\"Configuration.Save - saved {responseContent.Count()} bytes to configuration blob\");\n', '\n', '        return true;\n', '    }\n', '\n', '    // read configuration from storage and return it as file content\n', '    public static async Task<ByteArrayContent> GetContent()\n', '    {\n', '        byte[] configFileBytes = await Blob.GetBuffer();\n', '\n', '        Globals._log.LogInformation($\"Configuration.GetContent - total of {configFileBytes.Length} bytes read from storage\");\n', '        if (configFileBytes.Length == 0)\n', '        {\n', '            return null;\n', '        }\n', '\n', '        ByteArrayContent fileContent = new ByteArrayContent(configFileBytes);\n', '        /*\n', '        fileContent.Headers.ContentDisposition = new ContentDispositionHeaderValue(\"form-data\")\n', '        {\n', '            Name = \"Filedata\",\n', '            FileName = filename\n', '        };\n', '        fileContent.Headers.ContentType = new MediaTypeHeaderValue(\"application/gzip\");\n', '        */\n', '\n', '        return fileContent;\n', '    }\n', '};\n', '\n', 'class Utils\n', '{\n', '    public static async Task<FuncResult> PostRequest(string url, int numOfTries = 1, string postData = \"\")\n', '    {\n', '        FuncResult result = new FuncResult();\n', '        //Globals._log.LogError($\"Utils.PostRequest - postData: {postData}, tries: {numOfTries}\");\n', '\n', '        while (numOfTries > 0)\n', '        {\n', '            result = await PostRequest(url, postData);\n', '            if (result.status)\n', '            {\n', '                if ((result.other as HttpResponseMessage).StatusCode == HttpStatusCode.OK)\n', '                {\n', '                    break;\n', '                }\n', '            }\n', '            numOfTries--;\n', '            Globals._log.LogInformation($\"Utils.PostRequest - Error during POST [{postData}] to [{url}].\\n{numOfTries} more attempts will be done\");\n', '            Thread.Sleep(1000); // wait 1 sec before next try\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    // TODO: consider making this function more generic (i.e. add content)\n', '    static async Task<FuncResult> PostRequest(string url, string postData = \"\")\n', '    {\n', '        using ( var handler = new HttpClientHandler() )\n', '        {\n', '            // this will actually validate every server certificate\n', '            // this is the only reason for creating the HTTP handler instance\n', '            handler.ServerCertificateCustomValidationCallback = ( message, cert, chain, errors ) => { return true; };\n', '\n', '            using (var client = new HttpClient(handler))\n', '            {\n', '                // set request''s URL\n', '                client.BaseAddress = new Uri(url);\n', '\n', '                // add basic authentication\n', '                client.DefaultRequestHeaders.Authorization = Globals._authHeader;\n', '                if (null == client.DefaultRequestHeaders.Authorization)\n', '                {\n', '                    string message = \"Error generating authorization header\";\n', '                    Globals._log.LogError($\"Utils.PostRequest - {message}\");\n', '                    return new FuncResult(false, message);\n', '                }\n', '\n', '                // send put-config\n', '                HttpResponseMessage response = await client.PostAsync(\"\", string.IsNullOrEmpty(postData) ? null : new StringContent(postData));\n', '                string responseContent = await response.Content.ReadAsStringAsync();\n', '                Globals._log.LogInformation($\"Utils.PostRequest - response for [{url}, {postData}]: {responseContent}\");\n', '\n', '                return new FuncResult(true, responseContent, response);\n', '            }\n', '        }\n', '    }\n', '\n', '    // just use POST request for the given URL and content\n', '    public static async Task<HttpResponseMessage> PostUrl(string url, StringContent content)\n', '    {\n', '        using (var handler = new HttpClientHandler())\n', '        {\n', '            // this will actually validate every server certificate\n', '            // this is the only reason for creating the HTTP handler instance\n', '            handler.ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => { return true; };\n', '\n', '            using (var client = new HttpClient(handler))\n', '            {\n', '                client.BaseAddress = new Uri(url);\n', '\n', '                return await client.PostAsync(url, content);\n', '            }\n', '        }\n', '    }\n', '\n', '    // extract the username and password from the request''s data and genetate an authentication header value\n', '    public static System.Net.Http.Headers.AuthenticationHeaderValue GenerateAuthorizationValue()\n', '    {\n', '        // extract the username and password from the request''s body\n', '        string username = Globals._requestData?.username;\n', '        string password = Globals._requestData?.password;\n', '\n', '        if (string.IsNullOrEmpty(username) || string.IsNullOrEmpty(password))\n', '        {\n', '            return null;\n', '        }\n', '\n', '        var byteArray = Encoding.ASCII.GetBytes($\"{username}:{password}\");\n', '        return new System.Net.Http.Headers.AuthenticationHeaderValue(\"Basic\", Convert.ToBase64String(byteArray));\n', '    }\n', '\n', '    // extract ip and port either from the request (remote ip/post data) or by default (port)\n', '    public static string GetCallerAddress(HttpRequest req, Dictionary<string, string> idPortTable)\n', '    {\n', '        // for debugging - i can pass the port number in the request''s data\n', '        string remotePort = Globals._requestData?.accessPort;\n', '        if (string.IsNullOrEmpty(remotePort))\n', '        {\n', '            // default port when using single IP setup\n', '            remotePort = \"8443\";\n', '\n', '            // search for the appropriate port in the given table\n', '            foreach (var kvp in idPortTable)\n', '            {\n', '                // skip initiating Alteon\n', '                if (string.Equals(Globals._instanceId, kvp.Key, StringComparison.OrdinalIgnoreCase))\n', '                {\n', '                    // generate IP from request data and port from the above dictionary\n', '                    remotePort = kvp.Value;\n', '\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '\n', '        string ipAddress = $\"{Globals._remoteIp}:{remotePort}\";\n', '\n', '        return ipAddress;\n', '    }\n', '\n', '    public static Dictionary<string, string> BuildPortsTable(dynamic natRules)\n', '    {\n', '        Dictionary<string, string> ports = new Dictionary<string, string>();\n', '\n', '        // NAT rules response data may look like this:\n', '        /*\n', '        {\n', '            \"value\": [\n', '                {\n', '                    \"name\": \"natRule1.1\",\n', '                    \"id\": \"/subscriptions/subid/resourceGroups/testrg/providers/Microsoft.Network/loadBalancers/lb1/inboundNatRules/natRule1.1\",\n', '                    \"properties\": {\n', '                        \"provisioningState\": \"Succeeded\",\n', '                        \"frontendIPConfiguration\": {\n', '                            \"id\": \"/subscriptions/subid/resourceGroups/testrg/providers/Microsoft.Network/loadBalancers/lb1/frontendIPConfigurations/ip1\"\n', '                        },\n', '                        \"frontendPort\": 3390,\n', '                        \"backendPort\": 3389,\n', '                        \"enableFloatingIP\": false,\n', '                        \"idleTimeoutInMinutes\": 4,\n', '                        \"protocol\": \"Tcp\",\n', '                        \"enableTcpReset\": true,\n', '                        \"backendIPConfiguration\": {\n', '                            \"id\": \"/subscriptions/subid/resourceGroups/testrg/providers/Microsoft.Compute/virtualMachineScaleSets/vmss1/virtualMachines/1/networkInterfaces/nic1/ipConfigurations/ip1\"\n', '                        }\n', '                    }\n', '                },\n', '                {\n', '                    \"name\": \"natRule1.3\",\n', '                    \"id\": \"/subscriptions/subid/resourceGroups/testrg/providers/Microsoft.Network/loadBalancers/lb1/inboundNatRules/natRule1.3\",\n', '                    \"properties\": {\n', '                        \"provisioningState\": \"Succeeded\",\n', '                        \"frontendIPConfiguration\": {\n', '                            \"id\": \"/subscriptions/subid/resourceGroups/testrg/providers/Microsoft.Network/loadBalancers/lb1/frontendIPConfigurations/ip1\"\n', '                        },\n', '                        \"frontendPort\": 3392,\n', '                        \"backendPort\": 3389,\n', '                        \"enableFloatingIP\": false,\n', '                        \"idleTimeoutInMinutes\": 4,\n', '                        \"protocol\": \"Tcp\",\n', '                        \"enableTcpReset\": true,\n', '                        \"backendIPConfiguration\": {\n', '                            \"id\": \"/subscriptions/subid/resourceGroups/testrg/providers/Microsoft.Compute/virtualMachineScaleSets/vmss1/virtualMachines/3/networkInterfaces/nic1/ipConfigurations/ip1\"\n', '                        }\n', '                    }\n', '                }\n', '            ]\n', '        }\n', '        */            \n', '        // go through all the rules and:\n', '        // 1. get the instance rule name (value[i].name)\n', '        // 2. extract it''s id (instance rule name == <rule name>.<id>)\n', '        // 3. get the frontend port (values[i].properties.frontendPort)\n', '        // 4. add id & port to dictionary\n', '\n', '        foreach (var value in natRules.value)\n', '        {\n', '            string rulename = value.name;\n', '            string[] parts = rulename.Split(''.'');\n', '\n', '            if (parts.Length < 2)\n', '            {\n', '                Globals._log.LogError($\"NAT rules response does not contain instance ID: {rulename}\");\n', '                continue;\n', '            }\n', '\n', '            string port = value.properties.frontendPort;\n', '            ports.Add(parts[1], port);\n', '        }\n', '\n', '        Globals._log.LogInformation($\"Utils.BuildPortsTable - [instance id, port number]: {string.Join(\", \", ports)}\");\n', '        return ports;\n', '    }\n', '\n', '};\n', '\n', 'class Blob\n', '{\n', '    public static CloudBlockBlob _blob;\n', '\n', '    public static async Task<bool> Exists()\n', '    {\n', '        if (null != _blob)\n', '        {\n', '            return await _blob.ExistsAsync();\n', '        }\n', '\n', '        return false;\n', '        /*\n', '        Globals._log.LogInformation($\"Blob.Exists - fetch attributes from {_blob.Name}\");\n', '        await _blob.FetchAttributesAsync();\n', '        return (_blob.Properties.Length != 0);\n', '        */\n', '    }\n', '\n', '    public static async Task<bool> PutBuffer(byte[] buffer)\n', '    {\n', '        await _blob.UploadFromByteArrayAsync(buffer, 0, buffer.Length);\n', '        Globals._log.LogInformation($\"Blob.PutBuffer - wrote {buffer.Length} bytes to {_blob.Name}\");\n', '\n', '        return true;\n', '    }\n', '\n', '    public static async Task<byte[]> GetBuffer()\n', '    {\n', '        using (MemoryStream memoryStream = new MemoryStream())\n', '        {\n', '            //Download the blob.\n', '            await _blob.DownloadToStreamAsync(memoryStream);\n', '\n', '            byte[] buffer = memoryStream.ToArray();\n', '            Globals._log.LogInformation($\"Blob.GetBytes - read {buffer.Length} bytes\");\n', '\n', '            return buffer;\n', '        }\n', '    }\n', '};\n', '\n', 'class ClusterSync\n', '{\n', '    // upon ''apply'' command, get the updated configuration from the calling Alteon, save it and update all other\n', '    // Alteons in the cluster\n', '    public static async Task<FuncResult> HandleApplyRequest(HttpRequest req)\n', '    {\n', '        Globals._log.LogInformation($\"ClusterSync.HandleApplyRequest - first collect NAT rules\");\n', '        // get a list of all NAT rules\n', '        dynamic natRules = await AzureInterface.GetInboundNatRules();\n', '        // make a list of instance-ID to port according to nat rules response\n', '        Dictionary<string, string> idPortTable = Utils.BuildPortsTable(natRules);\n', '\n', '        // get the configuration from the calling Alteon\n', '        Globals._log.LogInformation($\"ClusterSync.HandleApplyRequest - get configuration from caller\");\n', '        HttpResponseMessage response = await AlteonInterface.GetConfig(req, idPortTable, 3);\n', '        if (null == response || response.StatusCode != HttpStatusCode.OK)\n', '        {\n', '            string responseStatus = await response.Content.ReadAsStringAsync();\n', '            Globals._log.LogInformation($\"ClusterSync.HandleApplyRequest - response status: {responseStatus}\");\n', '            \n', '            string message = $\"Error {responseStatus} when trying to get Alteon''s configuration (from {response.RequestMessage.RequestUri})\";\n', '            //string message = $\"Error {responseStatus} when trying to get Alteon''s configuration (from ...)\";\n', '            Globals._log.LogError($\"ClusterSync.HandleApplyRequest - {message}\");\n', '            return new FuncResult(false, message);\n', '        }\n', '\n', '        // read the response data\n', '        byte[] responseContent = await response.Content.ReadAsByteArrayAsync();\n', '        // save the configuration received\n', '        await Configuration.Save(responseContent);\n', '\n', '        // now start the sync process...\n', '\n', '        // now update all other Alteons...\n', '        // TODO: without await i can send all updates together, but (currently) without knowing when it completes\n', '        FuncResult result = await AlteonInterface.UpdateOthers(idPortTable, Globals._instanceId);\n', '\n', '        return result;\n', '    }\n', '\n', '\n', '    // updated the calling Alteon with an updated configuration (if exist)\n', '    public static async Task<FuncResult> HandleFirstApplyRequest(HttpRequest req)\n', '    {\n', '        FuncResult result;\n', '\n', '        Globals._log.LogInformation(\"ClusterSync.HandleFirstApplyRequest - calling Azure.GetInboundNatRules\");\n', '\n', '        // get a list of all NAT rules\n', '        dynamic natRules = await AzureInterface.GetInboundNatRules();\n', '        if (null == natRules)\n', '        {\n', '            string message = \"failed to retrieve NAT rules\";\n', '            Globals._log.LogError($\"HandlleFirstApplyRequest - {message}\");\n', '            return new FuncResult(false, message);\n', '        }\n', '\n', '        // make a list of instance-ID to port according to nat rules response\n', '        Dictionary<string, string> idPortTable = Utils.BuildPortsTable(natRules);\n', '        Globals._log.LogInformation($\"ClusterSync.HandleFirstApplyRequest - id-port table:\\n{idPortTable}\");\n', '\n', '        // get the host name/ip from the request\n', '        string address = Utils.GetCallerAddress(req, idPortTable);\n', '        if (string.IsNullOrEmpty(address))\n', '        {\n', '            string message = $\"caller address not found in NAT rules ([instance id, port number]): {string.Join(\", \", idPortTable)}\";\n', '            Globals._log.LogError($\"ClusterSync.HandleFirstApplyRequest - {message}\");\n', '            return new FuncResult(false, message);\n', '        }\n', '\n', '        // if storage is not empty - need to update calling Alteon''s configuration\n', '        Globals._log.LogInformation(\"ClusterSync.HandleFirstApplyRequest - check configuration files existance\");\n', '        if (await Configuration.Exists())\n', '        {\n', '            // use updated configuration to send it back to the requesting Alteon\n', '            result = await AlteonInterface.PutConfig(address, 3);\n', '        }\n', '        else\n', '        {\n', '            Globals._log.LogInformation(\"ClusterSync.HandleFirstApplyRequest - configuration not updated yet\");\n', '\n', '            // add SSL certificate\n', '            // only on first apply, when configuration was not uploaded yet\n', '            result = await AlteonCertificate.Set(address);\n', '            \n', '        }\n', '\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '\n', '        // now add license\n', '        result = await AlteonGelLicense.Set(address);\n', '\n', '        return result;\n', '    }\n', '};\n', '\n', '/// a collection of functionalities that handle GEL license\n', 'class AlteonGelLicense\n', '{\n', '    // license related\n', '    static string _licEntitlementIdKey = \"lmLicOperPendingEntitlementId\";\n', '    static string _licThroughputKey = \"lmLicOperThroughput\";\n', '    static string _licSubscriberKey = \"lmLicOperSubscrAddOn\";\n', '    static string _licSyncKey = \"lmLicOperSynclic\";\n', '    static string _licSyncValue = \"0\"; // [0(start)]\n', '\n', '    /// set license to Alteon (the one sending the first-apply)\n', '    public static async Task<FuncResult> Set(string address)\n', '    {\n', '        string licEntitlementIdValue = Globals._deployParams?.GelLicense.EntitlementId;\n', '        string licThroughputValue = Globals._deployParams?.GelLicense.Throughput;\n', '        string licSubscriberValue = Globals._deployParams?.GelLicense.Subscriber;\n', '\n', '        Globals._log.LogInformation($\"AlteonGelLicense.Set - entry\");\n', '\n', '        // to add a license, we should:\n', '        // 1. submit the entitlement id\n', '        // 2. submit the throughput\n', '        // 3. submit subscriber (perform/secure/ignore)\n', '        // 4. commit (sync) license\n', '\n', '        string url = $\"https://{address}/config\";\n', '\n', '        // submit entitlement id\n', '        string postData = $\"{{\\\"{_licEntitlementIdKey}\\\": \\\"{licEntitlementIdValue}\\\"}}\";\n', '        FuncResult result = await Utils.PostRequest(url, 3, postData);\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '\n', '        // submit throughput\n', '        postData = $\"{{\\\"{_licThroughputKey}\\\": \\\"{licThroughputValue}\\\"}}\";\n', '        result = await Utils.PostRequest(url, 3, postData);\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '\n', '        // submit subscriber\n', '        postData = $\"{{\\\"{_licSubscriberKey}\\\": \\\"{licSubscriberValue}\\\"}}\"; // 0/2/3 (ignore/perform/secure)\n', '        result = await Utils.PostRequest(url, 3, postData);\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '\n', '        // now sync\n', '        postData = $\"{{\\\"{_licSyncKey}\\\": \\\"{_licSyncValue}\\\"}}\"; // 0 (start)\n', '        result = await Utils.PostRequest(url, 3, postData);\n', '\n', '        return result;\n', '    }\n', '};\n', '\n', '// a collection of functions to handle SSL certificate injection\n', 'class AlteonCertificate\n', '{\n', '    /// set license to Alteon (the one sending the first-apply)\n', '    public static async Task<FuncResult> Set(string address)\n', '    {\n', '        // 1. set certificate key\n', '        // 2. set certificate\n', '\n', '        // TODO: temporary? - read key and data from files\n', '        string id = Globals._deployParams?.Certificate.Id;\n', '        string passphrase = Globals._deployParams?.Certificate.Passphrase;\n', '        string key = System.IO.File.ReadAllText($@\"{Globals._localPath}\\cert_key.txt\");\n', '        string data = System.IO.File.ReadAllText($@\"{Globals._localPath}\\cert_data.txt\");\n', '\n', '        Globals._log.LogInformation($\"AlteonCertificate.Set - key size: {key.Length}, data size: {data.Length}\");\n', '\n', '        // inject key\n', '        string url = $\"https://{address}/config/sslcertimport?renew=0&renewK=0&id={id}&type=key&src=txt&passphrase={passphrase}\";\n', '        FuncResult result = await Utils.PostRequest(url, 3, key);\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '\n', '        url = $\"https://{address}/config/sslcertimport?renew=0&renewK=0&id={id}&type=cert&src=txt\";\n', '        result = await Utils.PostRequest(url, 3, data);\n', '        if (!result.status)\n', '        {\n', '            return result;\n', '        }\n', '\n', '        result = await AlteonInterface.ApplyConfig(address);\n', '\n', '        return result;\n', '    }\n', '};\n', '\n', '// a collection of functions to interact with Azure\n', 'class AzureInterface\n', '{\n', '    // build the REST API to get a list of NAT rules for a specific Scale Set\n', '    static string GenerateNatRulesListUrl()\n', '    {\n', '        string subscriptionId = Globals._requestData?.subscriptionId;\n', '        string resourceGroup = Globals._requestData?.resourceGroupName;\n', '        string apiVersion = \"2018-08-01\";\n', '\n', '        return $\"https://management.azure.com/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Network/loadBalancers/{Globals._lbName}/inboundNatRules?api-version={apiVersion}\";\n', '    }\n', '\n', '    // each NAT rule also reflects a VM in the cluster, so i''m actually getting the cluster VMs as well\n', '    public static async Task<dynamic> GetInboundNatRules()\n', '    {\n', '        Globals._log.LogInformation(\"Azure.GetInboundNatRules - entry\");\n', '        // generate the appropriate URL\n', '        string queryUrl = GenerateNatRulesListUrl();\n', '\n', '        // send GET request to ARM to retrieve NAT rules\n', '        HttpResponseMessage response = await GetHttpResponse(queryUrl);\n', '\n', '        string responseContent = await response.Content.ReadAsStringAsync();\n', '        //Globals._log.LogInformation($\"Azure.GetInboundNatRules - response: {responseContent}\");\n', '\n', '        return JsonConvert.DeserializeObject(responseContent);\n', '    }\n', '\n', '    // send get request to ARM and return the response message\n', '    static async Task<HttpResponseMessage> GetHttpResponse(string url)\n', '    {\n', '        Globals._log.LogInformation($\"Azure.GetHttpResponse - request url: {url}\");\n', '        // first get an authorization token\n', '        // TODO: handle a global token with expiration mechanism\n', '        string token = await GetToken();\n', '\n', '        using (var handler = new HttpClientHandler())\n', '        {\n', '            // this will actually validate every server certificate\n', '            // this is the only reason for creating the HTTP handler instance\n', '            handler.ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => { return true; };\n', '\n', '            using (var client = new HttpClient(handler))\n', '            {\n', '                client.BaseAddress = new Uri(url);\n', '                client.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {token}\");\n', '\n', '                HttpResponseMessage response = await client.GetAsync(\"\");\n', '                Globals._log.LogInformation($\"Azure.GetHttpResponse - response: {response.ToString()}\");\n', '\n', '                return response;\n', '            }\n', '        }\n', '    }\n', '\n', '    // get an authorization token from ARM\n', '    static async Task<string> GetToken()\n', '    {\n', '        // ask for token using the given credentials\n', '        string tenantId = Globals._requestData?.tenantId;\n', '        string clientId = Globals._requestData?.clientId;\n', '        string clientSecret = Globals._requestData?.clientSecret;\n', '\n', '        // request a token\n', '        string url = $\"https://login.windows.net/{tenantId}/oauth2/token\";\n', '\n', '        string resourceData = $\"https://management.core.windows.net/&client_id={clientId}&grant_type=client_credentials&client_secret={clientSecret}\";\n', '        StringContent content = new StringContent($\"resource={resourceData}\", Encoding.UTF8, \"application/x-www-form-urlencoded\");\n', '\n', '        HttpResponseMessage response = await Utils.PostUrl(url, content);\n', '\n', '        string responseContent = await response.Content.ReadAsStringAsync();\n', '\n', '        // extract the token from the response\n', '        dynamic resData = JsonConvert.DeserializeObject(responseContent);\n', '        string token = resData?.access_token;\n', '        Globals._log.LogInformation($\"Azure.GetToken - response: {token}\");\n', '\n', '        return token;\n', '    }\n', '};\n', '\n', '// a collection of functions to interact with Alteon\n', 'class AlteonInterface\n', '{\n', '    public static async Task<HttpResponseMessage> GetConfig(HttpRequest req, Dictionary<string, string> idPortTable, int numOfTries)\n', '    {\n', '        HttpResponseMessage response = null;\n', '\n', '        // get the host name/ip from the request\n', '        string ipAddress = Utils.GetCallerAddress(req, idPortTable);\n', '        string url = $\"https://{ipAddress}/config/getcfg?pkey=yes\";\n', '        Globals._log.LogInformation($\"Alteon.GetConfig - going to query {url}\");\n', '\n', '        while (numOfTries > 0)\n', '        {\n', '            response = await GetConfig(url);\n', '            if (response.StatusCode == HttpStatusCode.OK)\n', '            {\n', '                break;\n', '            }\n', '            numOfTries--;\n', '            Globals._log.LogInformation($\"Alteon.GetConfig - Error during Get-Config, {numOfTries} more attempts will be done\");\n', '            Thread.Sleep(1000); // wait 1 sec before next try\n', '        }\n', '\n', '        return response;\n', '    }\n', '\n', '    // generic get-config method - send get-config request to Alteon VM\n', '    public static async Task<HttpResponseMessage> GetConfig(string url)\n', '    {\n', '        using ( var handler = new HttpClientHandler() )\n', '        {\n', '            // this will actually validate every server certificate\n', '            // this is the only reason for creating the HTTP handler instance\n', '            handler.ServerCertificateCustomValidationCallback = ( message, cert, chain, errors ) => { return true; };\n', '\n', '            using (var client = new HttpClient(handler))\n', '            {\n', '                // add basic authentication\n', '                client.DefaultRequestHeaders.Authorization = Globals._authHeader;\n', '                if (null == client.DefaultRequestHeaders.Authorization)\n', '                {\n', '                    string message = \"Alteon.GetConfig - Error generating authorization header\";\n', '                    Globals._log.LogError(message);\n', '                    return null;\n', '                }\n', '\n', '                client.DefaultRequestHeaders.Add(\"Passphrase\", Globals._passphrase);\n', '\n', '                client.BaseAddress = new Uri(url);\n', '                HttpResponseMessage response = await client.GetAsync(\"\");\n', '\n', '                Globals._log.LogInformation($\"Alteon.GetConfig - response: {response}\");\n', '\n', '                return response;\n', '            }\n', '        }\n', '    }\n', '\n', '    public static async Task<FuncResult> PutConfig(string address, int numOfTries)\n', '    {\n', '        FuncResult result = new FuncResult(false, \"\");\n', '\n', '        while (numOfTries > 0)\n', '        {\n', '            result = await PutConfig(address);\n', '            if (result.status)\n', '            {\n', '                break;\n', '            }\n', '            numOfTries--;\n', '            Globals._log.LogInformation($\"Alteon.PutConfig - Error during Put-Config, {numOfTries} more attempts will be done\");\n', '            Thread.Sleep(1000); // wait 1 sec before next try\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    // generic put-config method - use given configuration file and send it to an Alteon VM\n', '    static async Task<FuncResult> PutConfig(string address)\n', '    {\n', '        string url = $\"https://{address}/config/configimport?pkey=yes\";\n', '        Globals._log.LogInformation($\"Alteon.PutConfig - going to put config to {url}\");\n', '\n', '        using ( var handler = new HttpClientHandler() )\n', '        {\n', '            // this will actually validate every server certificate\n', '            // this is the only reason for creating the HTTP handler instance\n', '            handler.ServerCertificateCustomValidationCallback = ( message, cert, chain, errors ) => { return true; };\n', '\n', '            using (var client = new HttpClient(handler))\n', '            {\n', '                // set request''s URL\n', '                client.BaseAddress = new Uri(url);\n', '\n', '                // add basic authentication\n', '                client.DefaultRequestHeaders.Authorization = Globals._authHeader;\n', '                if (null == client.DefaultRequestHeaders.Authorization)\n', '                {\n', '                    string message = \"Error generating authorization header\";\n', '                    Globals._log.LogError($\"Alteon.PutConfig - {message}\");\n', '                    return new FuncResult(false, message);\n', '                }\n', '\n', '                Globals._log.LogInformation($\"Alteon.PutConfig - authorization added: {client.DefaultRequestHeaders.Authorization.ToString()}\");\n', '\n', '                client.DefaultRequestHeaders.Add(\"Passphrase\", Globals._passphrase);\n', '\n', '                using (var content = new MultipartFormDataContent())\n', '                {\n', '                    /*\n', '                    it makes sense to use a one-time-created value to add to the request''s content, as this\n', '                    value would be created once outside this function and be reused in consequtive calls.\n', '                    apprently, after each request, this value is disposed, so i need to create it every\n', '                    time when creating a new request :-(\n', '                    */\n', '                    ByteArrayContent configFile = await Configuration.GetContent();\n', '                    if (null == configFile)\n', '                    {\n', '                        return new FuncResult(false, \"Alteon.PutConfig - couldn''t get a valid configuration\");\n', '                    }\n', '                    content.Add(configFile);\n', '\n', '                    // send put-config\n', '                    HttpResponseMessage response = await client.PostAsync(\"\", content);\n', '                    Globals._log.LogInformation($\"Alteon.PutConfig - response: {response.ToString()}\");\n', '                    string responseContent = await response.Content.ReadAsStringAsync();\n', '                    Globals._log.LogInformation($\"Alteon.PutConfig - response content: {responseContent}\");\n', '\n', '                    if (response.StatusCode != HttpStatusCode.OK)\n', '                    {\n', '                        string message = $\"Error {responseContent} when trying to put-config to {url}\";\n', '                        Globals._log.LogError($\"Alteon.PutConfig - {message}\");\n', '                        return new FuncResult(false, message);\n', '                    }\n', '\n', '                    // now send apply to that Alteon\n', '                    FuncResult result = await ApplyConfig(address);\n', '                    Globals._log.LogInformation($\"Alteon.PutConfig - result of apply: {result}\");\n', '\n', '                    return new FuncResult(true, responseContent);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    // go through all existing Alteons and sent put-config request to them (skip the originating Alteon)\n', '    public static async Task<FuncResult> UpdateOthers(Dictionary<string, string> instancesPorts, string instanceId)\n', '    {\n', '        FuncResult result = new FuncResult();\n', '        int successfulApplys = 0;\n', '        int totalApplys = 0;\n', '\n', '        Globals._log.LogInformation(\"Alteon.UpdateOthers - enter\");\n', '\n', '        foreach (KeyValuePair<string, string> kvp in instancesPorts)\n', '        {\n', '            // skip initiating Alteon\n', '            if (string.Equals(instanceId, kvp.Key, StringComparison.OrdinalIgnoreCase))\n', '            {\n', '                continue;\n', '            }\n', '            // generate IP from request data and port from the above dictionary\n', '            string address = $\"{Globals._remoteIp}:{kvp.Value}\";\n', '            Globals._log.LogInformation($\"Alteon.UpdateOthers - handling address {address}\");\n', '\n', '            result = await PutConfig(address, 3);\n', '            if (result.status)\n', '            {\n', '                successfulApplys += 1;\n', '            }\n', '            totalApplys += 1;\n', '        }\n', '\n', '        result.status = true;\n', '        result.message = $\"successfully applied {successfulApplys} VMs out of {totalApplys} tries\";\n', '        return result;\n', '    }\n', '\n', '    public static async Task<FuncResult> ApplyConfig(string address)\n', '    {\n', '        Globals._log.LogInformation(\"Alteon.ApplyConfig - entry\");\n', '        \n', '        string url = $\"https://{address}/config?action=clusterSyncApply\";\n', '\n', '        return await Utils.PostRequest(url);\n', '    }\n', '};\n', '\n', 'public static async Task<IActionResult> Run(HttpRequest req, CloudBlockBlob blob, ILogger log)\n', '{\n', '    string reqMethod = req.Method;\n', '    log.LogInformation($\"C# HTTP trigger function processing a {reqMethod} request.\");\n', '    if (!string.Equals(reqMethod, \"post\", StringComparison.OrdinalIgnoreCase))\n', '    {\n', '        return new BadRequestObjectResult(\"Please use a POST request when using this function\");\n', '    }\n', '\n', '    // simple logic:\n', '    // 1. if first apply and storage contains a configuration -\n', '    //    - put configuration from storage to Alteon\n', '    // 2. if apply -\n', '    //    - get configuration from Alteon\n', '    //    - save configuration to storage\n', '    //    - populate configuration too all other Alteons in the set\n', '    // x. if first apply and configuration storage is empty (we don''t really need this) -\n', '    //    - get configuration from Alteon\n', '    //    - store the configuration in cloud storage\n', '    //    - populate configuration to all other Alteons in the set\n', '\n', '    // set some globals\n', '    await Globals.Set(req, blob, log);\n', '\n', '    // extract first apply indication from request body\n', '    string firstApply = Globals._requestData?.firstApply;\n', '\n', '    // indication must exist\n', '    if (!string.IsNullOrEmpty(firstApply))\n', '    {\n', '        // check for first apply indication\n', '        if (string.Equals(firstApply, \"true\", StringComparison.OrdinalIgnoreCase))\n', '        {\n', '            var result = await ClusterSync.HandleFirstApplyRequest(req);\n', '            Globals._log.LogInformation($\"ClusterSync.HandleFirstApplyRequest returned {result.ToString()}\");\n', '\n', '            return (ActionResult)new OkObjectResult($\"ClusterSync.HandleFirstApplyRequest result: {result.ToString()}\");\n', '        }\n', '        // check for apply indication (first apply is false)\n', '        else if (string.Equals(firstApply, \"false\", StringComparison.OrdinalIgnoreCase))\n', '        {\n', '            var result = await ClusterSync.HandleApplyRequest(req);\n', '            Globals._log.LogInformation($\"HandleApplyRequest returned {result.ToString()}\");\n', '\n', '            return (ActionResult)new OkObjectResult($\"apply, put-config result: {result.ToString()}\");\n', '        }\n', '        else\n', '        {\n', '            return new BadRequestObjectResult(\"Please pass a valid value (true/false) for ''firstApply'' indication in the request body\");\n', '        }\n', '    }\n', '    else\n', '    {\n', '        return new BadRequestObjectResult(\"Please pass a ''firstApply'' indication on the query string or in the request body\");\n', '    }\n', '}\n')]",
                "function_params.json" : "[variables('azureFunctionJsonParams')]"

              }
            }
          }
       ]                        
    },
    {
        "type": "Microsoft.Web/sites/hostNameBindings",
        "name": "[concat(parameters('alteonsAzureFuncName'), '/', parameters('alteonAzureFuncHostNameBindingsName'))]",
        "apiVersion": "2018-02-01",
        "location": "[parameters('location')]",
        "scale": null,
        "properties": {
            "siteName": "[parameters('alteonsAzureFuncName')]",
            "domainId": null,
            "hostNameType": "Verified"
        },
        "dependsOn": [
            "[resourceId('Microsoft.Web/sites', parameters('alteonsAzureFuncName'))]"
        ]
    }    
],
"outputs": {
    "alteonsAzureFuncName": {
        "type": "String",
        "value": "[listsecrets(resourceId('Microsoft.Web/sites/functions', parameters('alteonsAzureFuncName'), 'TestFunctionCM'),'2016-08-01').trigger_url]"
    }
}
}